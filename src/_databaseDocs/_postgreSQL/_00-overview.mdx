:::info Completing this guide

This guide will take approximately 30 minutes. By the end, you'll walk away with an understanding of:

- How the Hasura API authoring lifecycle works.
- How to connect a PostgreSQL database.
- How to run and develop with Hasura locally.
- How to use the new Hasura DDN CLI to create, iterate on, and deploy a supergraph to Hasura DDN.

:::

## Introduction

In this guide, you'll learn how you can build an API on PostgreSQL using Hasura DDN. As an experienced engineer, when
building APIs on PostgreSQL, you understand that 50-90% of your API is already implicitly defined by the modeling work
you've done within PostgreSQL. The remaining work â€” business logic â€” is what requires you to maintain custom code.

Traditional API frameworks solve this by requiring you to write code and use ORMs to abstract away the database, leading
to performance debt down the road. Hasura provides a revolutionary way of creating APIs on PostgreSQL that ensures the
highest levels of performance upfront. Hasura helps you automatically maintain an API for parts of your API that can
already be defined by the existing modeling work in PostgreSQL, and offers a lightweight and high-performance way to
write business logic wherever required.

Our approach is based on two key principles:

1. **Query compilation that is native to the database with push-down**: This principle ensures that queries are
   optimized and executed directly within the database, minimizing overhead and maximizing performance.

2. **Lazy evaluationâ€”only compute what is needed**: By evaluating only the necessary computations, Hasura minimizes
   resource usage and enhances performance efficiency.

This results in an API that your consumers will love because of its standardization and on-demand composability. When
leveraging Hasura's capabilities, your API will approach theoretical optimal performance, as if you wrote a custom,
optimized query for every single API endpoint ðŸš€

## API authoring lifecycle

The API authoring lifecycle with Hasura involves the following steps:

1. **Definition by models and commands in Hasura metadata**: The API is defined through models and commands that are
   stored within Hasura's metadata.

2. **Backing by database entities, code, or queries**: These models and commands are backed by the underlying database
   entities, custom code, or native queries.

3. **CLI tooling for easy authoring**: Hasura's CLI makes it easy to author models and commands by introspecting the
   database, code, or native queries.

By following these steps, you can efficiently create and maintain high-performance APIs on PostgreSQL with Hasura DDN.

## Modeling basics

Designing your database to align with your API model is essential for creating efficient and scalable applications. By
working backwards from the desired API, you can structure your database to optimize for read operations, which is often
the primary use case for most consumers. This approach works well for greenfield applications, but existing databases
can also be adapted using techniques like [views](https://www.postgresql.org/docs/current/tutorial-views.html).

### Start with the API

1. **Define the API**: Outline the resources, data structures, and relationships needed by your application.
2. **Design the Database**: Create tables, columns, and relationships that map directly to the API model.

### Focus on Reads

- **Optimize for queries**: Design your database to efficiently handle read operations, as they are typically the most
  frequent.
- **Use indexes**: Ensure that columns used in `WHERE`, `JOIN`, and `ORDER BY` clauses are indexed to improve
  performance.
