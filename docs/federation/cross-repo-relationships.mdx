---
sidebar_label: Cross-repo Relationships
sidebar_position: 4
description: "Learn how to create relationships across subgraphs in different repositories in Hasura DDN."
keywords:
  - relationships
  - cross-repo relationships
  - subgraphs
  - supergraph
  - hasura ddn
  - graphql api
  - data connectors
  - permissions
  - federation
  - multi-repo federation
  - single-repo federation
  - schema stitching
  - modular development
  - git workflows
seoFrontMatterUpdated: true
---

# Cross-repo Relationships

## Connecting across subgraphs with relationships

When you have multiple subgraphs, either in a single-repo or multi-repo setup, you can link [types together using
relationships](/supergraph-modeling/relationships.mdx). This is done by creating a `Relationship` object in metadata
which defines how fields from one type map to a `model` or `command`.

### Single-repo relationships

In a single-repo setup, relationships are straightforward to manage. All subgraphs are in the same repository and the
Hasura VS Code extension can be used to assist with authoring relationships, providing auto-complete and
validation.

### Cross-repo Relationships

:::info Advanced plan

You will need a project on the [DDN Advanced plan](https://hasura.io/pricing) to use multi-repo federation and
cross-repo relationships.

:::

In a multi-repo setup, subgraphs which contain objects you want to relate can be in subgraphs managed in different
repositories which you don't have access. In these cases the Hasura VS Code extension cannot validate the entirety
of the `Relationship` object and you will manually author cross-repo relationships and ensure that the field
mappings are correct.

You can still easily use the Hasura DDN console to explore the supergraph test relationships across subgraphs once
you have created a build. This will help you to ensure that the relationships are working as expected before you
deploy the supergraph to production.

### Relationship Example

For more information on how to create `Relationships` check out [this page](/supergraph-modeling/relationships.mdx).

Let's say you have a supergraph with two subgraphs, each managed in different repositories: `users` and `products`.

The `users` subgraph in repo 'A' has a `User` type with a field called `favorite_product_id`.

The `products` subgraph in repo 'B' has a `Product` type with a field called `id`.

To create a relationship between these two types in different repositories, you would create a `Relationship` object in
the `users` subgraph metadata as normal.

[//]: # (warning from LSP??)

```yaml
kind: Relationship
version: v1
definition:
  name: favorite_product
  sourceType: User
  target:
    model:
      name: Product
      subgraph: products
      relationshipType: Object
  mapping:
    - source:
        fieldPath:
          - fieldName: favorite_product_id
      target:
        modelField:
          - fieldName: id
```

This `Relationship` object defines a relationship called `favorite_product` from the `User` type to the `Product`
type. The `mapping` field specifies how the `favorite_product_id` field in the `User` type maps to the `id` field
in the `Product` type.

With this relationship defined, you can now query the `favorite_product` field on the `User` type to retrieve the
related `Product`.

```graphql
query {
  users {
    id
    name
    favorite_product {
      id
      name
    }
  }
}
```