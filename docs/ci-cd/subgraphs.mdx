---
sidebar_position: 5
sidebar_label: Subgraphs
description:
  "Explore Hasura's subgraphs functionality designed for multi-team projects. Understand the process of metadata object
  management, subgraph-specific guidelines, and data source ownership within Hasura. Discover how subgraphs facilitate
  efficient organization and controlled access to project metadata, enhancing team collaboration on Hasura projects."
keywords:
  - hasura
  - data source ownership
  - subgraphs
  - metadata management
  - multi-team projects
  - project management
  - hasura project structure
  - team collaboration
  - api management
  - application development
seoFrontMatterUpdated: true
---

# Subgraphs

## Introduction

For a multi-team organization working on a Hasura project, it can make sense for any one team to not have access to all
metadata objects. Subgraphs introduces the notion of a module system for your Hasura metadata.

A project can have a collection of subgraphs and the project becomes the 'union' of metadata objects across all
subgraphs of the project. Each subgraph can then be accessed and updated independently.

A manifest file with subgraphs looks something like the following:

```yaml
kind: SupergraphManifest
version: v1
definition:
  environment: dev
  name: base
  mode: replace
  envfile: .local.yaml
  supergraph:
    resources:
      - supergraph/**/*.hml
  # highlight-start
  subgraphs:
    - name: app
      resources:
        - app/**/*.hml
      connectors:
        app_connector:
          path: app/app_connector
          manifestFile: app_connector.build.hml
        app_functions:
          path: app/app_functions
          manifestFile: app_functions.build.hml
    - name: user_experience
      resources:
        - user_experience/**/*.hml
      connectors:
        user_experience_connector:
          path: user_experience/user_experience_connector
          manifestFile: user_experience_connector.build.hml
  # highlight-end
```

## Subgraph Lifecycle

### Create

You can create a subgraph for a project on Hasura DDN using the CLI:

```bash
ddn create subgraph <SUBGRAPH_NAME>
```

This will create the subgraph on Hasura DDN, but you'll need to add a connector manifest to create the local subgraph
directory. To do so, run the following command:

```bash
ddn add connector-manifest <NAME_FOR_CONNECTOR> --subgraph <SUBGRAPH_NAME_FROM_PREVIOUS_STEP> --hub-connector <NAME_OF_CONNECTOR> --type <LOCAL_OR_CLOUD>
```

### Manage

You can easily list all the available subgraphs for a project using the CLI:

```bash
ddn get subgraph
```

You can connect new data sources, add new types, etc. to a subgraph. Any files you add to the subgraph directory will be
picked up by the metadata build and associated with the subgraph.

### Delete

Delete a subgraph by running:

```bash
ddn delete subgraph <SUBGRAPH_NAME>
```

## Ownership Rules

The metadata objects in subgraphs must follow the ownership rules for metadata objects as outlined below.

### DataConnector/ HasuraHubDataConnector

The data source metadata object (`DataConnector`/ `HasuraHubDataConnector`) doesn't depend on (or reference) any other
metadata object. Hence, any subgraph can define a data source.

:::info Subgraph ownership

The subgraph that defines a data source then owns it. This means that no other subgraph can reference this data source
in their type representations, model, etc.

Violating this rule will result in the metadata build failing with the error,
`unable to build schema: subgraph is not consistent: the following data source is defined more than once: <data source name>`.

:::

### ObjectType

The `ObjectType` metadata object also doesn't reference any other metadata object. Thus, any subgraph can define an
`ObjectType`.

### DataConnectorScalarRepresentation

The `DataConnectorScalarRepresentation` metadata object references the data connector metadata object and the scalar
type object. Thus, the data source in a `DataConnectorScalarRepresentation` should be owned by the **same** subgraph.

### ScalarType

The `ScalarType` metadata object also doesn't reference any other metadata object. Thus, **any** subgraph can define a
`ScalarType`.

### Model

A `Model` metadata object references a data type. Also, the model's `source` references a data source and some data
types in type mappings. **Thus, the same subgraph should own the types and the data source.**

### Command

A `Command` metadata object references an output data type. Thus, the subgraph defining the `Command` metadata object
should also define the output data type.

### Relationship

The `Relationship` metadata object references a source type and a target model. The source type used in the
`Relationship` should be owned by the subgraph defining the `Relationship`.

:::info Target model ownership

The target model can be from any subgraph. This allows us to define relationships across subgraphs. To use a model from
another subgraph as the target, you will need to reference the subgraph in the target model definition. Please refer to
the [`TargetModel`](/supergraph-modeling/relationships.mdx#targetmodel) for syntax.

:::

### TypePermissions

The `TypePermissions` metadata object references a type (for which the permission is being defined). Thus, the subgraph
defining the `TypePermissions` should own the type referenced.

### ModelPermissions

Similar to `TypePermissions`, the subgraph should also own the model referenced in the `ModelPermissions` metadata
object.

### CommandPermissions

The `CommandPermissions` metadata object references a command, which should be defined in the same subgraph.

### AuthConfig

This is defined in the supergraph.

:::info Only one auth config allowed per project

There can be only one `AuthConfig` in the project's metadata. If there is more than one `AuthConfig`, then the metadata
build will fail with the error `Found duplicate authentication config`.

:::

## Other Rules

Apart from ownership rules, metadata with subgraphs should also follow the following rules:

### Duplicate Subgraphs

Metadata should not define two subgraphs with same name.

### Duplicate Metadata Objects

Metadata should also not define the same subgraph object twice (either in the same subgraph or in different subgraphs).
If you violate this rule, then the metadata build will fail with the error
`subgraph constraints violated - found multiple subgraphs with the same name`.
