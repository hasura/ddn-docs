---
sidebar_position: 2
sidebar_label: Configuration
description:
  "Explore the comprehensive guide to configuring projects on Hasura's Data Delivery Network. Learn about build
  profiles, subgraphs, and using Hasura CLI for efficient project management."
keywords:
  - hasura configuration
  - data delivery network
  - hasura CLI
  - metadata management
  - yaml configuration
  - project setup
  - hasura version control
  - build profiles
  - hasura subgraphs
  - hasura project management
seoFrontMatterUpdated: true
---

# Configuration

## Introduction

Hasura v3 introduces a new configuration model for projects on the Hasura Data Delivery Network (DDN). This model relies
on three families of files:

| File type              | Description                                               |
| ---------------------- | --------------------------------------------------------- |
| `*-build-profile.yaml` | Build profiles for a project.                             |
| `hasura.yaml`          | The main configuration file and entrypoint for a project. |
| `*.hml`                | Hasura metadata files for a project.                      |

## Basic configuration

When using the [hasura3 CLI](/cli/overview.mdx) to create a new project, you'll run the following command:

```bash
hasura3 project create .
```

This will generate a new project directory in the current folder with the following structure:

```bash
<PROJECT_NAME>
├── build-profile.yaml
├── hasura.yaml
├── subgraphs
│   └── default
│       ├── commands
│       ├── dataconnectors
│       └── models
└── supergraph
    ├── auth-config.hml
    └── compatibility-config.hml
```

### build-profile.yaml

By default, your `build-profile.yaml` is populated with the following content:

```yaml
version: 2
spec:
  environment: default
  mode: replace
  supergraph:
    resources:
      - supergraph/*
  subgraphs:
    - name: default
      resources:
        - "subgraphs/default/**/*.hml"
```

Here, you can see that the `build-profile.yaml` file contains `version`, `spec`, and `subgraphs` sections. The `version`
section is used to specify the version of the configuration file.

The `spec` section contains the following fields:

| Field         | Description                                          |
| ------------- | ---------------------------------------------------- |
| `environment` | The environment to use for the build.                |
| `mode`        | The mode to use for the build. `Replace` by default. |
| `supergraph`  | The supergraph resources to use for the build.       |

This tells Hasura DDN to use the `default` namespace and any `hml` files in the `subgraphs/default` directory when
creating a new build.

### hasura.yaml

By default, your `hasura.yaml` is populated with the following content:

```yaml
version: 1
project: <PROJECT_NAME>
buildProfiles:
  - build-profile.yaml
defaultBuildProfile: build-profile.yaml
```

You can see that the `hasura.yaml` file contains a `version` and a `project` section. The `version` section is used to
specify the version of the configuration file. The `project` section is used to specify the project name.

The `hasura.yaml` file also contains a `buildProfiles` section. This section is used to specify the build profiles
associated with the project. As you can see from this example, we only have one build profile, `build-profile.yaml`
which is also identified as the default to use when creating a new build. **At least one build profile is required for a
project.**

### Subgraphs directory

Each subgraph for your supergraph will follow the same format. Inside of the `subgraphs` directory, each subgraph is
identified by a directory with the name of the subgraph. Within that, you'll find three directories:

```bash
└── <SUBGRAPH_NAME>
│       ├── commands
│       ├── dataconnectors
│       └── models
```

Each subdirectory contains `hml` files for the corresponding metadata object. We'll take a look at a more advanced
example after we cover the basics of the directory structure.

### Supergraph directory

Your `supergraph` directory will contain two configuration files by default: the `auth-config.hml` and
`compatibility-config.hml` files. These files are used to configure authentication and compatibility for your data
supergraph.

#### AuthConfig

```yaml
kind: AuthConfig
version: v1
definition:
  allowRoleEmulationBy: admin
  mode:
    webhook:
      method: Post
      url: https://auth.pro.hasura.io/webhook/ddn?role=admin
```

The `AuthConfig` object is used to configure authentication for your data supergraph. You can learn more about
authentication in the [Auth section](/auth/overview.mdx).

#### CompatibilityConfig

```yaml
kind: CompatibilityConfig
date: 2023-10-19
```

The `CompatibilityConfig` object is used to configure compatibility for your data supergraph.

:::info What is HML?

These are both `hml` files, which is a new file format for Hasura metadata. It is a superset of the existing `yaml`
format, and is designed to provide a more flexible and extensible way to define metadata. You can leverage the power of
the [Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura) to quickly and
easily author `hml` files.

:::

Your `hml` files contain metadata objects according to the OpenDD spec. In the example above, we could add a
`HasuraHubDataConnector` object to connect to a data source. Then, import our tables as models and create a build on
Hasura DDN.

However, in the next section, we'll look at how to use subgraphs to organize metadata and break up our `hml` file into
smaller, more governable pieces.

## Advanced configuration

Let's consider a data supergraph which has multiple teams collaborating on it. Each team has their own set of data
sources. We can use subgraphs to organize our metadata and break up our `hml` file into smaller, more governable pieces.
We can also utilize build profiles to create different builds for different environments.

Imagine this file structure:

```bash
<PROJECT_NAME>
├── build-profile.yaml
├── build-profile_staging_billing.yaml
├── hasura.yaml
├── subgraphs
│   └── app
│       ├── commands
│       ├── dataconnectors
│           └── app.hml
│       └── models
│           ├── cart_items.hml
│           ├── carts.hml
│           ├── categories.hml
│           ├── coupons.hml
│           ├── manufactuers.hml
│           ├── notifications.hml
│           ├── orders.hml
│           ├── products.hml
│           ├── reviews.hml
│           └── users.hml
│   └── billing
│       ├── commands
│       ├── dataconnectors
│           └── billing.hml
│       └── models
│           ├── invoices.hml
│           ├── payments.hml
│           ├── refunds.hml
└── supergraph
    ├── auth-config.hml
    └── compatibility-config.hml
```

### Build profiles

In this example, we have two build profiles: `build-profile.yaml` and `build-profile_staging_billing.yaml`. The
`build-profile.yaml` file contains the following content:

```yaml
version: 2
spec:
  environment: default
  mode: replace
  supergraph:
    resources:
      - supergraph/*
  subgraphs:
    - name: default
      resources:
        - "subgraphs/**/*.hml"
```

Whereas the `build-profile_staging_billing.yaml` file contains the following content:

```yaml
version: 2
spec:
  environment: staging
  mode: replace
  supergraph:
    resources:
      - supergraph/*
  subgraphs:
    - name: default
      resources:
        - "subgraphs/billing/**/*.hml"
```

The two build profiles, `build-profile.yaml` and `build-profile_staging_billing.yaml`, are designed to cater to
different environments and teams. The `build-profile.yaml` is configured for the default environment and is set to
include all subgraphs in the subgraphs directory. This configuration is suitable for a general development team working
on various parts of the project.

On the other hand, `build-profile_staging_billing.yaml` is specifically configured for the staging environment and is
set to include only the billing subgraphs. This allows a team working specifically on the billing feature to iterate and
test their changes in a separate staging environment without affecting the rest of the project. This separation of
concerns enhances the development workflow by allowing teams to work independently on their respective features.

### hasura.yaml

The `hasura.yaml` in the root of the project contains the following content:

```yaml
version: 1
project: <PROJECT_NAME>
buildProfiles:
  - ./build-profile.yaml
  - ./build-profile_staging_billing.yaml
defaultBuildProfile: build-profile.yaml
```

This lets Hasura DDN know that we have two build profiles, and that the `build-profile.yaml` is the default to use when
creating a new build.

### metadata.hml

While it's not recommended, you could deploy a project with only one `hml` file that contains all of your metadata
objects, including your `HasuraHubDataConnector` objects, models, and commands. However, this would be difficult to
manage and maintain.

With a more advanced configuration we can leverage subgraphs and break apart our supergraph into team-ownable components
where we have multiple `hml` files stored in their respective subgraph directories.

The contents of the `hml` files can be that of any valid OpenDD metadata object.

[//]: # "## Resources TODO"
[//]: #
[//]: # "Check out [this repository](#) on GitHub for a working example of the advanced configuration described above."
