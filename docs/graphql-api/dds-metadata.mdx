---
sidebar_position: 2
sidebar_label: DDS Metadata
description: Hasura GraphQL API - DDS Metadata
keywords:
  - hasura
  - graphql
  - api
  - data domain metadata
  - dds metadata
---

# Hasura GraphQL API: DDS Metadata

## Introduction

<!-- TODO: Links to other docs when available -->

Hasura provides automatically generated GraphQL APIs for your data domain. To set up the GraphQL API, you'll need to
define the following DDS metadata objects:

- [modelGraphqlApi](#model-graphql-api): Specify the root fields to be exposed over GraphQL API for a model.
- [scalarTypeGraphqlExpression](#scalar-type-graphql-expression): Customize type names of schema generated for data
  source scalars.

## Model GraphQL API

The `modelGraphqlApi` DDS object facilitates establishing GraphQL APIs on any model.

### Metadata Structure

To define the `modelGraphqlApi` object, you will need the model's name and at least one select-unique query API
definition. Find the JSON schema for the object below.

```json
{
  "kind": "modelGraphqlApi",
  "modelName": <ModelName>,
  "selectUniques": [<SelectUniqueObject>],
  "selectMany": <SelectManyObject>,
  "filterExpressionType": <GraphQLTypeName>,
  "argumentsInputField": <ArgumentsFieldName>,
  "argumentsInputType": <ArgumentsInputType>
}
```

| Field                | Type                                                              | Required | Description                                                                                                                     |
|----------------------|-------------------------------------------------------------------|----------|---------------------------------------------------------------------------------------------------------------------------------|
| modelName            | `String`                                                          | true     | Name of the model.                                                                                                              |
| selectUniques        | [[SelectUnique](/graphql-api/queries.mdx#selectunique-structure)] | true     | Define Select unique queries.                                                                                                   |
| selectMany           | [SelectMany](/graphql-api/queries.mdx#selectmany-structure)       | false    | Definition to enable select many query.                                                                                         |
| filterExpressionType | `String`                                                          | false    | The type name for the `where` filter input object for select many query. The default value is of format `{ModelName}_bool_exp`. |
| argumentsInputField  | `String`                                                          | false    | The input field name for model's arguments. Default value is `args`.                                                            |
| argumentsInputType   | `String`                                                          | false    | The type name for model arguments input object. The default value is of format `{ModelName}_arguments`.                         |

:::info Note

It is not necessary to define `argumentsInputField` and `argumentsInputType` if arguments are not defined on the model.

:::

### Examples

Find examples of the `modelGraphqlApi` DDS object for:

1. select-unique queries [here](/graphql-api/queries.mdx#examples).
2. select-many queries [here](/graphql-api/queries.mdx#examples-1).


## Scalar Type GraphQL Expression

For [Select Many](/graphql-api/queries.mdx#select-many) queries, it is necessary to have a `where` argument to filter
rows. The `where` argument is an input object which contains the model's type fields along with `_or`, `_and` and
`_not` operators.

The model's type field should be mapped to the data source's object type field, which must have a non-list scalar type.
For example, consider a `Post` model whose type is `post` containing the following fields:
- `post_id`: `Int`
- `content`: `String`
- `tags`: [`String`]

The `Post` model is backed by a source. The fields of the model are mapped to a `source_post` object type as per the
following:
- `post_id` -> `source_post`.`id` of type `Integer`
- `content` -> `source_post`.`content` of type null `TEXT`
- `tags` -> `source_post`.`tags` of type `[TEXT]`

In the above case, only the `post_id` and `content` fields are present in `where` argument input object.

You cannot filter objects using the `tags` field as it is mapped to an array scalar.

Each field is an input object with comparison operators as fields. These operators are defined for each scalar type
in the data source's schema. <!-- TODO: refer data source schema docs when available -->

```graphql
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: Integer_Scalar_Comparison_Expression_Type_Name
  content: TEXT_Scalar_Comparison_Expression_Type_Name
}
```

Using the `scalarTypeGraphqlExpression` DDS object, you can provide a custom type name for the comparison input object
of each scalar type.

### Metadata Structure

To define `scalarTypeGraphqlExpression`, you need the name of the data source and the name of the scalar type.

```json
{
  "kind": "ScalarTypeGraphQlExpression",
  "dataSource": <DataSourceName>,
  "scalarTypeName": <ScalarTypeName>,
  "graphqlComparisonExpressionTypeName": <GraphQLTypeName>
}
```

| Field                               | Type     | Required | Description                                   |
|-------------------------------------|----------|----------|-----------------------------------------------|
| dataSource                          | `String` | true     | Name of the data source.                      |
| scalarTypeName                      | `String` | true     | Name of the scalar type                       |
| graphqlComparisonExpressionTypeName | `String` | true     | The type name for the comparison input object |

:::info Note

Defining a `scalarTypeGraphqlExpression` DDS object for a scalar type is completely optional. If not defined,
the `graphqlComparisonExpressionTypeName` will be of `{DataSource}_{ScalarTypeName}_comparison_exp` format.

:::

### Example

Consider the `Post` model example explained [above](#scalar-type-graphql-expression).

To define a comparison object type name for `TEXT` and `Integer` scalar types:

```json
[
  {
    "kind": "scalarTypeGraphqlExpression",
    "dataSource": "my_source",
    "scalarTypeName": "TEXT",
    "graphqlComparisonExpressionTypeName": "String_Comparison_Exp"
  },
  {
    "kind": "scalarTypeGraphqlExpression",
    "dataSource": "my_source",
    "scalarTypeName": "Integer",
    "graphqlComparisonExpressionTypeName": "Int_Comparison_Exp"
  }
]
```

Assuming the `TEXT` scalar type is exposing a `like` comparison operator and the `Integer` scalar type is exposing
`greater_than` and `less_than` operators:

```json
{
  "TEXT": {
    "comparison_operators": {
      "like": {
        "argument_type": {
          "type": "named",
          "name": "TEXT"
        }
      }
    }
  },
  "Integer": {
    "comparison_operators": {
      "like": {
        "greater_than": {
          "type": "named",
          "name": "Integer"
        },
        "less_than": {
          "type": "named",
          "name": "Integer"
        }
      }
    }
  }
}
```

And, the source scalar types are [represented](/metadata-modeling/types.mdx#scalar-type-representation) as DDS types as
follows:

- `TEXT` -> DDS `String`
- `Integer` -> DDS `Int`

The GraphQL schema generated for the `scalarTypeGraphqlExpression` DDS objects above will appear as follows:

```graphql
input String_Comparison_Exp {
  like: String
}
input Int_Comparison_Exp {
  greater_than: Int
  less_than: Int
}
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: Int_Comparison_Exp
  content: String_Comparison_Exp
}
```

If no `scalarTypeGraphqlExpression` object defined for `TEXT` and `Integer` scalar types, then the GraphQL schema is
generated as:

```graphql
input my_source_TEXT_comparison_exp {
  like: String
}
input my_source_Integer_Comparison_Exp {
  greater_than: Int
  less_than: Int
}
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: my_source_Integer_Comparison_Exp
  content: my_source_TEXT_comparison_exp
}
```
