---
sidebar_position: 1
sidebar_label: Typescript
description: "Explore how to mutate data using the TypeScript data connector."
keywords:
  - hasura
  - ddn
  - hasura ddn
  - typescript
  - custom logic
  - api management
  - graphql api
---

import Thumbnail from "@site/src/components/Thumbnail";

# Mutations via the TypeScript Connector

## Introduction

We can use the [Node.js Lambda Connector](https://github.com/hasura/ndc-nodejs-lambda) to write custom mutations in
TypeScript with Node.js. This allows us to write mutations and custom business logic for our mutations and scale read
and write operations separately. This pattern is known as **Command Query Separation (CQS)**.

## Prerequisites

If you've never used Hasura DDN, we recommend that you first go through the [quickstart](/local-dev.mdx).
Additionally, you will need to follow the guide in the [README.md](https://github.com/hasura/ndc-nodejs-lambda) of the
repo for the [Node.js Lambda Connector](https://github.com/hasura/ndc-nodejs-lambda) to learn more about how to add it
to your Hasura project. From here on, we'll assume you have a working TypeScript connector in your project. ðŸ˜Š


## Adding a custom mutation

Inside the `functions.ts` file of your Node.js Lambda connector, you can add a custom mutation.

For example, let's say you want to add a custom mutation to create a user in a PostgreSQL table on your `default`
subgraph and also hash their password before storing it

You can do this by adding the following code to the `functions.ts` file:

```typescript
import { Client } from 'pg';
import bcrypt from 'bcrypt';

// Define the User type using TypeScript
// Note: For plain JavaScript, you can omit the type definition
// Or if using TypeScript, you can define it in a separate `.d.ts` file
type User = {
  name: string;
  email: string;
  password: string; // Add a password field to the User type
};

/**
 * Inserts a user into the database and returns the inserted user.
 * Hash password for secure storage.
 *
 * @param user The user to insert into the database. Expects a name, email, and password.
 * @returns The user that was inserted into the database.
 */
export async function insertUser(user: User): Promise<Omit<User, "password">> {
  // Get your database connection string.
  // NB!! Use env vars for this in production NB!!
  const connectionString = "postgresql://username:password@localhost:5432/mydb";

  const client = new Client({
    connectionString,
  });
  await client.connect();

  // Hash the user's password before storing it
  const saltRounds = 10; // Pretty decent number of rounds
  const hashedPassword = await bcrypt.hash(user.password, saltRounds);

  const result = await client.query(
    `INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING *`,
    [user.name, user.email, hashedPassword] // Use the hashed password here
  );

  const rows = result.rows.map((row) => ({
    id: row.id,
    name: row.name,
    email: row.email,
    // Do not return the password field for security reasons
  }));

  await client.end();

  return rows[0];
}

```

This:
- creates a function called `insertUser`
- takes in a user's name, email, and password
- hashes their password
- inserts into the `users` table in the database.
- returns the inserted user without password.

We're using the [`pg` PostgreSQL client](https://www.npmjs.com/package/pg) to connect to the database and run the query
and `bcrypt` to hash the password, but since this is a Node.js Lambda function, you can use any combination of Node.js
libraries you want.

After you've tracked the function and created a new build, you can use the function in your GraphQL API:

[//]: # (<Thumbnail)

[//]: # (  src="/img/graphql-api/mutations/0.1.1_console_insert-user-mutation.png")

[//]: # (  alt="Insert user mutation using CQS")

[//]: # (  className="no-shadow overview-img")

[//]: # (/>)

You can then repeat this process to scale your mutations independently.
