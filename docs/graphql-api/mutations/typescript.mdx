---
sidebar_position: 1
sidebar_label: CQRS via the TypeScript Connector
description: "Explore how to mutate data using the TypeScript data connector."
keywords:
  - hasura
  - ddn
  - hasura ddn
  - typescript
  - custom logic
  - api management
  - graphql api
---

import Thumbnail from "@site/src/components/Thumbnail";

# CQS via the TypeScript Connector

## Introduction

**Command Query Separation (CQS) is a pattern that separates read and write operations for a data store.** This pattern
is useful when you want to scale read and write operations independently.

You can do this by delegating mutation responsibilities to the
[TypeScript connector](https://hasura.io/connectors/typescript-deno). The TypeScript connector is a custom connector
that allows you to write custom logic in TypeScript. You can use this connector to write custom mutations that can be
used to mutate data in the database.

:::info Prerequisites

If you've never used the TypeScript connector, we recommend you to go through the
[quickstart](/getting-started/local-dev.mdx). Additionally, at the very least, check out the docs for the
[TypeScript Connector](https://github.com/hasura/ndc-typescript-deno) to learn more about how to add it to your Hasura
project. From here on, we'll assume you have a working TypeScript connector in your project.

:::

## Adding a custom mutation

Inside the `index.ts` of any of your subgraphs, you can add a custom mutation. For example, let's say you want to add a
custom mutation to create a user in a PostgreSQL table on your `default` subgraph. You can do this by adding the
following code to the `index.ts` file of `default`:

```typescript
import { Client } from "https://deno.land/x/postgres/mod.ts";
import { load } from "https://deno.land/std@0.210.0/dotenv/mod.ts";

// Define the User type
type User = {
  name: string;
  email: string;
};

/**
 * Inserts a user into the database and returns the inserted user
 *
 * @param user The user to insert into the database. Expects an id, name, and email.
 * @returns The user that was inserted into the database.
 */
export async function insertUser(user: User): Promise<User> {
  // Get the database connection string from the environment
  const env = await load();
  // This is the connection string for the database in a scoped .env file in the **same** directory
  // as this file.
  const connectionString: string = env["PG_DB_URL"];

  // Create the client to connect to the database
  const client = new Client(connectionString);
  await client.connect();

  const result = await client.queryArray`
    INSERT INTO users (name, email)
    VALUES (${user.name}, ${user.email})
    RETURNING *
  `;

  const rows = result.rows.map((row) => ({
    id: row[0] as string,
    name: row[1] as string,
    email: row[2] as string,
  }));

  await client.end();

  return rows[0];
}
```

This creates a function called `insertUser` that takes in a user and inserts it into the `users` table in the database.
It then returns the inserted user.

We're using the [PostgreSQL client](https://deno.land/x/postgres) to connect to the database and run the query. You can
use any client you want to connect to the database.

After you've tracked the function and created a new build, you can use the function in your GraphQL API:

<Thumbnail
  src="/img/graphql-api/mutations/0.1.1_console_insert-user-mutation.png"
  alt="Insert user mutation using CQS"
  className="no-shadow overview-img"
/>

You can then repeat this process to scale your mutations independently.
