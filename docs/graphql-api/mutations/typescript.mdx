---
sidebar_position: 1
sidebar_label: Typescript
description: "Explore how to mutate data using the TypeScript data connector."
keywords:
  - hasura
  - ddn
  - hasura ddn
  - typescript
  - custom logic
  - api management
  - graphql api
---

import Thumbnail from "@site/src/components/Thumbnail";

# CQS via the TypeScript Connector

## Introduction

**Command Query Separation (CQS) is a pattern that separates read and write operations for a data store.** This pattern
is useful when you want to scale read and write operations independently.

You can do this by delegating mutation responsibilities to the
[Node.js Lambda Connector](https://github.com/hasura/ndc-nodejs-lambda). This is a custom connector which allows you
to write custom logic in TypeScript for Node.js. You can use this connector to write custom mutations that can be used
to mutate data in the database.

:::info Prerequisites

If you've never used Hasura DDN, we recommend that you first go through the [quickstart](/local-dev.mdx).
Additionally, you will need to follow the guide in the README.md of the repo for the
[Node.js Lambda Connector](https://github.com/hasura/ndc-nodejs-lambda) to learn more about how to add it to your Hasura
project. From here on, we'll assume you have a working TypeScript connector in your project. ðŸ˜Š

:::

## Adding a custom mutation

Inside the `index.ts` of your subgraphs, you can add a custom mutation. For example, let's say you want to add a
custom mutation to create a user in a PostgreSQL table on your `default` subgraph. You can do this by adding the
following code to the `index.ts` file of `default`:

```typescript
import { Client } from 'pg';

// Define the User type using TypeScript
// Note: For plain JavaScript, you can omit the type definition
// Or if using TypeScript, you can define it in a separate `.d.ts` file
type User = {
  name: string;
  email: string;
};

/**
 * Inserts a user into the database and returns the inserted user.
 *
 * @param user The user to insert into the database. Expects a name and email.
 * @returns The user that was inserted into the database.
 */
export async function insertUser(user: User): Promise<User> {
  // Get your database connection string. NB! Use environment variables for this in production
  const connectionString = "postgresql://username:password@localhost:5432/mydb";

  // Create the client to connect to the database
  const client = new Client({
    connectionString,
  });
  await client.connect();

  const result = await client.query(
    `INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *`,
    [user.name, user.email]
  );

  const rows = result.rows.map((row) => ({
    id: row.id,
    name: row.name,
    email: row.email,
  }));

  await client.end();

  return rows[0];

}
```

This creates a function called `insertUser` that takes in a user and inserts it into the `users` table in the database.
It then returns the inserted user.

We're using the [`pg` PostgreSQL client](https://www.npmjs.com/package/pg) to connect to the database and run the query.
You can use any client you want to connect to the database.

After you've tracked the function and created a new build, you can use the function in your GraphQL API:

<Thumbnail
  src="/img/graphql-api/mutations/0.1.1_console_insert-user-mutation.png"
  alt="Insert user mutation using CQS"
  className="no-shadow overview-img"
/>

You can then repeat this process to scale your mutations independently.
