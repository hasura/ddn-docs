---
sidebar_position: 2
sidebar_label: Configuration
description: "Documentation for the setup process for the Hasura PostgreSQL connector, including connection URI details, native queries, and mutations."
keywords:
  - hasura postgresql setup
  - connector configuration
  - graphql api integration
  - database connection uri
  - native sql queries
  - graphql mutations
  - data modeling
  - api customization
  - hasura configuration guide
  - database schema management
seoFrontMatterUpdated: true
---

# Configuration

## Introduction

Below, you'll find information about how to configure the PostgreSQL connector.

The connector will create an empty configuration as follows:

```yaml
---
version: 1
connectionUri:
  uri: ""
metadata:
  tables: {}
  nativeQueries: {}
  aggregateFunctions: {}
  comparisonOperators: {}
```

Once you enter your connection string for a PostgreSQL database and refresh your data source using the
[Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura), the `"tables"` and
`"aggregate_functions"` sections will be auto-populated based on the current state of the database.

These will always be regenerated from scratch.

:::warning Subject to change

During this active development phase, the configuration structure is subject to change.

:::

## PostgreSQL connection URI

The PostgreSQL database URL should follow the [PostgreSQL connection URI form][libpq: Connection Strings], which looks
like this:

```
postgresql://[user[:password]@][host[:port]][/dbname][?param1=value2&param2=value2&...]
```

Remember to encode any ambiguous characters using standard URI encoding. For example, if you have an `@` in your
username, it will need to be written as `%40`.

[libpq: Connection Strings]: https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING

## Native Queries

Native queries can be defined by adding them to the `"nativeQueries"` section of a connector. Each query is specified as
SQL. The return structure of the query must be explicitly specified in the `"columns"` field.

Native queries can take arguments using the `{{argument_name}}` syntax. Arguments must be specified along with their
type. The arguments are not interpolated, but provided to your data source as parameters, and therefore must be specific
values, not arbitrary SQL.

### Queries

Here's an example which filters a table called `"Artist"`:

```yaml
---
version: 1
connectionUri:
  uri: postgresql://alice@database.host
metadata:
  tables: {}
  nativeQueries:
    artist_below_id:
      sql: SELECT * FROM public."Artist" WHERE "ArtistId" < {{id}}
      columns:
        ArtistId:
          name: ArtistId
          type: int4
        Name:
          name: Name
          type: varchar
      arguments:
        id:
          name: id
          type: int4
```

This will create a query called `"artist_below_id"` which takes a single argument called `"id"` of type `int4`. The
query will return a list of objects with the fields `"ArtistId"` and `"Name"`.

### Mutations

Native Query mutations can be defined the same way as regular Native Queries, with a few important tweaks:

1. The Native Query should include a field `isProcedure: true`.
2. The SQL should include a `RETURNING` clause, listing the returned columns (use `RETURNING *` to return all columns).

Here's an example which inserts into a table called `"Artist"`:

```yaml
metadata:
  tables: {}
  nativeQueries:
    insert_artist:
      isProcedure: true
      sql: INSERT INTO public."Artist" VALUES ({{id}}, {{name}}) RETURNING *
      columns:
        ArtistId:
          name: ArtistId
          type: int4
        Name:
          name: Name
          type: varchar
      arguments:
        id:
          name: id
          type: int4
        name:
          name: name
          type: varchar
```

This example can be used to insert a new artist:

```graphql
mutation {
  insert_artist(args: { id: 1, name: "Bob" }) {
    affected_rows
    returning {
      ArtistId
      Name
    }
  }
}
```

To expose a Native Query mutation via the GraphQL API, add it as a procedure
[command](/supergraph-modeling/commands.mdx) to the Hasura metadata.
