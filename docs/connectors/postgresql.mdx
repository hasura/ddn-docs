---
sidebar_position: 4
sidebar_label: PostgreSQL
description: Hasura Native Data Connector for PostgreSQL
keywords:
  - hasura
  - graphql
  - postgres
  - postgresql
---

# Native Data Connector for PostgreSQL

The Native Data Connector for PostgreSQL is our flagship connector, with rich support for all kinds of queries.

## Configuration

:::info Subject to change

During this active development phase, the configuration structure is subject to change.

:::

The connector will create an empty configuration as follows:

```json
{
  "version": 1,
  "connection_uris": [],
  "metadata": {
    "tables": {},
    "native_queries": {}
  },
  "aggregate_functions": {}
}
```

Once you enter your connection string for a PostgreSQL database and resubmit your metadata using the
[Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura), the `"tables"` and
`"aggregate_functions"` sections will be auto-populated based on the current state of the database.

These will always be regenerated from scratch.

### PostgreSQL connection URI

The PostgreSQL database URL should follow the [PostgreSQL connection URI form][libpq: Connection Strings], which looks
like this:

```
postgresql://[user[:password]@][host[:port]][/dbname][?param1=value2&param2=value2&...]
```

Remember to encode any ambiguous characters using standard URI encoding. For example, if you have an `@` in your
username, it will need to be written as `%40`.

[libpq: Connection Strings]: https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING

### Multi-region database configuration

The `connection_uris` field can take on two formats:

* A list of database uris, denoting a region-agnostic set read-only servers
* An object with keys `reads`, and `writes`, each an object where each key maps
  a region to a list of database servers.

Example, region agnostic setup:

```json
{
  "connection_uris":
    [
      "postgresql://user:password@db-server1/default_db",
      "postgresql://user:password@db-server2/default_db"
    ]
}
```

Example, multi-region setup:
```json
{
  "connection_uris":
    {
      "reads":
        {
          "aws-us-east-1":
            [
              "postgresql://user:password@db-server-boston/default_db",
              "postgresql://user:password@db-server-new-york/default_db"
            ],
          "aws-us-west-1":
            [
              "postgresql://user:password@db-server-san-fransisco/default_db",
              "postgresql://user:password@db-server-los-angeles/default_db"
            ]
        },
      "writes":
        {
          "aws-up-northeast-1":
            [
              "postgresql://user:password@db-server-singapore/default_db",
              "postgresql://user:password@db-server-kuala-lumpur/default_db"
            ]
        }
}
```

:::info Current support

Currently only queries are supported, so supplying any `writes`
serves has no effect.

:::

:::info Current support

Currently only a single database per region is supported, so only the
first uri supplied will be used.

:::

### Native Queries

Native queries can be defined by adding them to the `"native_queries"` section. Each query is specified as SQL. The
return structure of the query must be explicitly specified in the `"columns"` field.

Native queries can take arguments using the `{{argument_name}}` syntax. Arguments must be specified along with their
type. The arguments are not interpolated, but provided to PostgreSQL as parameters, and therefore must be specific
values, not arbitrary SQL.

Here's an example which filters a table called `"Artist"`.

```json
{
  "version": 1,
  "connection_uris": ["postgresql://alice@database.host"],
  "metadata": {
    "tables": {},
    "native_queries": {
      "artist_below_id": {
        "sql": "SELECT * FROM public.\"Artist\" WHERE \"ArtistId\" < {{id}}",
        "columns": {
          "ArtistId": {
            "name": "ArtistId",
            "type": "integer"
          },
          "Name": {
            "name": "Name",
            "type": "character varying"
          }
        },
        "arguments": {
          "id": {
            "name": "id",
            "type": "integer"
          }
        }
      }
    }
  }
}
```

## Scalar types

SQL data types are mapped to GraphQL types. The current mappings are as follows:

| SQL data type                   | GraphQL type |
| ------------------------------- | ------------ |
| `boolean`                       | `Boolean`    |
| `smallint`                      | `Int`        |
| `integer`                       | `Int`        |
| `bigint`                        | `Int`        |
| `numeric`                       | `Float`      |
| `real`                          | `Float`      |
| `double precision`              | `Float`      |
| `character`                     | `String`     |
| `character varying` (`varchar`) | `String`     |
| `text`                          | `String`     |
| `date`                          | `String`     |
| `time with time zone`           | `String`     |
| `time without time zone`        | `String`     |
| `timestamp with time zone`      | `String`     |
| `timestamp without time zone`   | `String`     |

Other SQL scalar types are unsupported, but may still work in certain situations.

:::info Data type aliases

Note that many of these SQL data types have aliases in PostgreSQL, which can be found in the [PostgreSQL documentation
on data types][PostgreSQL: data types].

[PostgreSQL: data types]: https://www.postgresql.org/docs/current/datatype.html

:::

## Nested types

The connector does not currently support nested data structures, such as `array`, `hstore`, `json`, or `jsonb`, though
they may still work in certain situations.

## Queries

The connector supports all query operations; see the general documentation for details.

### Predicates

The `_is_null` operator checks whether a value is `NULL`.

The following binary operators are supported when filtering:

| Name                       | GraphQL operator | PostgreSQL operator | GraphQL types |
| -------------------------- | ---------------- | ------------------- | ------------- |
| equals                     | `_eq`            | `=`                 | all           |
| not equals                 | `_neq`           | `<>`                | all           |
| less than                  | `_lt`            | `<`                 | all           |
| less than or equal to      | `_lte`           | `<=`                | all           |
| greater than               | `_gt`            | `>`                 | all           |
| greater than or equal to   | `_gte`           | `>=`                | all           |
| like                       | `_like`          | `LIKE`              | `String`      |
| not like                   | `_nlike`         | `NOT LIKE`          | `String`      |
| case-insensitive like      | `_ilike`         | `ILIKE`             | `String`      |
| not case-insensitive like  | `_nilike`        | `NOT ILIKE`         | `String`      |
| similar                    | `_similar`       | `SIMILAR TO`        | `String`      |
| not similar                | `_nsimilar`      | `NOT SIMILAR TO`    | `String`      |
| regex                      | `_regex`         | `~`                 | `String`      |
| not regex                  | `_nregex`        | `!~`                | `String`      |
| case-insensitive regex     | `_iregex`        | `~`                 | `String`      |
| not case-insensitive regex | `_niregex`       | `!~`                | `String`      |

The `_not`, `_and`, and `_or` operators all work as usual.

## Mutations

Mutations are currently not supported by the connector.
