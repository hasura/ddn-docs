---
sidebar_position: 4
sidebar_label: "Relationships connect data"
description: "Relationships allow you to connect data across different models."
keywords:
  - relationship
  - data modeling
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Thumbnail from "@site/src/components/Thumbnail";

# Relationships Connect Data

## Introduction

Relationships allow you to connect data, enabling you to query data across multiple entities.

Examples include:

- Querying a `Customer` and at the same time getting their `Orders` and each `Product` item in those orders.
- Querying an `Order` and also getting a live currency conversion for the price of the order.

Many relationships can be detected when introspecting a data source, for instance from foreign keys in a relational
database. You can add these relationships to your metadata with the DDN CLI.

Relationships can also be manually added to your metadata.

### Creating a relationship

Relationships are defined in metadata from an [object type](/supergraph-modeling/types.mdx#objecttype-objecttype), to a
[model](/supergraph-modeling/models.mdx) or [command](/supergraph-modeling/commands.mdx). But since models and commands
are also defined with object types, you can think of relationships as being between models and commands.

As an example, you can configure a relationship so that you can also get Orders when querying a Customer.

```yaml title="Create a relationship in your metadata:"
---
kind: Relationship
version: v1
definition:
  sourceType: Customers # The source object type which also defines the model
  name: orders # The name we want to use when we query the Orders from the Customer
  target:
    model: # The target can be a model or a command
      name: Orders # The target model that we want to access when we query the Orders from the Customer
      relationshipType: Array # The relationship type which can be Object or Array. Since a customer can have many orders, we use an Array.
  mapping: # the mapping defines which field on the source object type maps to which field on the target model
    - source:
        fieldPath:
          - fieldName: customerId # The field on the source object type that we want to map to the target model
      target:
        modelField:
          - fieldName: customerId # The field on the target model that we want to map to the source object type
```

By defining a `Relationship` object, all [models](/supergraph-modeling/models.mdx) or
[commands](/supergraph-modeling/commands.mdx) whose output type is the source object type defined in the relationship
will now have a connection to the target model or command.

### Updating a relationship

Your underlying data source may change over time. You can update your relationship to reflect these changes.

For example, imagine you have a `post-user` relationship, and the posts previously used a field named `userId`. Now,
however, that field name has changed to `authorId`.

First, update your connector configuration and models to reflect the changed field name.

```bash title="Update your DataConnectorLink:"
ddn connector-link update <connector_name> --subgraph <path_to_subgraph.yaml>
```

```bash title="Then, update your model:"
ddn model update <connector_name> users
```

Then edit the relationship configuration in subgraph metadata.

```yaml title="Edit the existing metadata file:"
# In whichever HML file contains your relationship
kind: Relationship
version: v1
definition:
  name: user
  source: Post
  target:
    model:
      name: User
      relationshipType: Object
  mapping:
    - source:
        fieldPath:
          - fieldName: authorId # this is the line that has changed
      target:
        modelField:
          - fieldName: id
```

### Deleting a relationship

If you no longer need a relationship, simply delete the metadata object.

## Reference

You can learn more about relationships in the metadata reference [docs](/supergraph-modeling/relationships.mdx).
