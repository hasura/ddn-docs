---
sidebar_position: 2
sidebar_label: Quickstart from VS Code
description:
  Learn how to create a new Hasura project using VS Code and new Hasura CLI, connect to a database, and execute your
  first query to enhance your GraphQL application development process.
keywords:
  - hasura
  - graphql
  - vs code
  - quickstart
  - postgreSQL
  - metadata
  - hasura cli
  - query
  - hasura project
  - data sources
seoFrontMatterUpdated: true
toc_max_heading_level: 2
---

import Thumbnail from "@site/src/components/Thumbnail";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart from VS Code

## Introduction

In this guide, we'll walk you through the steps to create a new Hasura project, connect a database, execute your first
query, create lightning-fast production builds, and incorporate business logic using TypeScript ‚Äî all with VS Code and
the **new Hasura CLI**. Throughout this guide, you'll be introduced to new Hasura concepts, like builds, our new
metadata structure, and more.

:::tip Prerequisites

1. The [new Hasura CLI](/cli/overview.mdx)
2. The [Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura)
3. A PostgreSQL database

You can connect a local PostgreSQL database to Hasura DDN using the new [Hasura CLI](/cli/overview.mdx). If you don't
have a PostgreSQL database and prefer to connect to a cloud provider, check out our friends at
[Neon](https://neon.tech).

:::

:::info Don't want to set up a database?

We've provisioned a read-only database for you to use for this guide if you'd like. You can use the following connection
string in Step 3:

```text
postgresql://read_only:kd4555jkfjfkdj39f8f8d9d@35.236.11.122:5432/v3-docs-sample-app
```

:::

## Step 1: Log into Hasura

To make a secure connection, you'll need a personal access token (PAT) from Hasura Cloud:

1. Head [here](https://cloud.hasura.io/account-settings/access-tokens) to generate your PAT.
2. Use the following command to add the token to the CLI, thereby logging you in:

```bash
hasura3 login --pat <YOUR_PAT>
```

:::info New CLI?!

Yep! If you can't tell already, we've completely rewritten the CLI from the ground up. You can learn more about the new
commands by running:

```bash
hasura3 --help
```

:::

## Step 2: Create a new project

To create a new project, use the following command, passing the directory where you want to create the project as an
argument. This command will create the configuration files and directory structure by default:

```bash
hasura3 init --dir <PROJECT_DIRECTORY>
```

The CLI will prompt you with the following:

```bash
Use the arrow keys to navigate: ‚Üì ‚Üë ‚Üí ‚Üê
Please choose how you would like to initialise Hasura DDN?
# highlight-start
  Create a new project        |        (Start building on a new DDN project)
# highlight-end
    From an existing project
    Empty project
```

Choose `Create a new project` and the CLI will respond with the following:

```bash
Creating a new project
Creating hasura.yaml ...
Creating build-profile ...
Creating metadata.hml ...
Project <PROJECT_NAME> is created at <DIR>
```

:::info What's a project?

Each project on Hasura DDN can have a corresponding local project that can be used for development. This local project
contains the following structure by default:

```text
‚îú‚îÄ‚îÄ build-profile.yaml
‚îú‚îÄ‚îÄ hasura.yaml
‚îú‚îÄ‚îÄ subgraphs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ default
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ commands
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ dataconnectors
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ models
‚îî‚îÄ‚îÄ supergraph
    ‚îú‚îÄ‚îÄ auth-config.hml
    ‚îî‚îÄ‚îÄ compatibility-config.hml
```

We'll dive into how to use these files as we continue through this guide. However, if you'd like more information on the
new project structure, see our page on [project configuration](#).

:::

## Step 3: Connect a data source

Inside the `/subgraphs/default/dataconnectors` directory, create a new file called `app.hml`. This directory will
contain the configuration for your data sources. We'll use this file to connect to a PostgreSQL database.

Then, start typing `HasuraHubDataConnector` on a new line. Hit `Enter` and the extension will automatically populate the
rest of the template for you:

```yaml
kind: HasuraHubDataConnector
version: v1
definition:
  name:
  connectorId:
  connectorConfiguration:
    - region:
      mode:
      configuration:
        version:
```

| Field                    | Description                                                                                                                                              |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`                   | The name of your data source. Put `default` for now.                                                                                                     |
| `connectorId`            | The ID of the connector you want to use. In this example, we'll use `hasura/postgres`.                                                                   |
| `connectorConfiguration` | List of regional configurations or your data connector. You can specify different configurations for different regions.                                  |
| `region`                 | Hit `Ctrl + Space` and choose the region that your database is closest to. If you're not sure, just use `gcp-us-east4`.                                  |
| `mode`                   | This can be `ReadOnly`, `ReadWrite` and `WriteOnly`. In this example, we'll use `ReadWrite`.                                                             |
| `configuration`          | The configuration for your data source. Contains `version`, `connectionUri`, and other fields.                                                           |
| `version`                | Version of the data source configuration. We'll use `1`.                                                                                                 |
| `connectionUri`          | Connection string for your Postgres database which can be a value or a [secret](/ci-cd/secrets.mdx). For this guide, enter your database URL as a value. |

<Tabs groupId="db-location" className="api-tabs">
<TabItem value="hosted" label="Hosted Database">

If your database is hosted on a cloud provider, you can connect to it by copying your connection string which should
look like this:

```text
postgresql://<USERNAME>:<PASSWORD>@<HOST>:<PORT>/<DATABASE_NAME>
```

</TabItem>
<TabItem value="local" label="Local Database">

### Step 3.1: Start your database

If you want to connect a local database for development, you can use the new [Hasura CLI](/cli/overview.mdx) to create a
local daemon and securely connect to your database.

Start your local database. For example, if you are using Docker, you can run the following command:

```bash
docker run -d --name <DATABASE_NAME> -e POSTGRES_PASSWORD=<YOUR_PASSWORD> -p 5432:5432 <DATABASE_IMAGE>
```

### Step 3.2: Start the daemon

Start the Hasura daemon with the `daemon start` command:

```bash
hasura3 daemon start
```

The daemon will block this window while it runs.

### Step 3.3: Create a Secure Connect tunnel

Open a new tab or window for your terminal and run the `create` command:

```bash
hasura3 tunnel create <SOCKET>
```

The `<SOCKET>` argument is the address of your local database. For example, if you are running a local PostgreSQL
database on the default port, you would use `localhost:5432`.

The CLI will return a URL that you can use to connect to your database. You should use this URL to form a connection
string for your database, like this:

```text
postgresql://<USERNAME>:<PASSWORD>@<URL_RETURNED_BY_THE_CLI>/<DATABASE_NAME>
```

</TabItem>
</Tabs>

After you add the `connectionUri` information in `HasuraHubDataConnector`, your metadata field should look something
like this:

```yaml
kind: HasuraHubDataConnector
version: v1
definition:
  name: app
  connectorId: hasura/postgres
  connectorConfiguration:
    - region: gcp-us-east4
      mode: ReadWrite
      configuration:
        version: 1
        # highlight-start
        connectionUri:
          uri:
            value: postgres://<YOUR_POSTGRESQL_USERNAME>:<YOUR_POSTGRESQL_PASSWORD>@<HOST_ADDRESS>:<PORT_NUMBER>/<DATABASE_NAME>
        # highlight-end
```

In VS Code, press `Command + Shift + P` (Mac) or `Ctrl + Shift + P` (Windows) to open the Command Palette. Type
`hasura refresh data source` and choose the option that appears.

<Thumbnail src="/img/get-started/0.0.1_vs-code-refresh-data-source.png" alt="Execute a query" width="1000px" />

You should now see the name you provided in the previous step. Clicking this will introspect your data source and add
information to your metadata about the tables and views in your database. The VS Code extension will fetch your data
source's schema from the wherever it's hosted; this will take a few seconds.

:::tip Autocomplete your metadata

You can always hit `Ctrl + Space` in VSCode while editing HML files to get autocompletion üöÄ

:::

## Step 4: Scaffold your metadata

From here, you can immediately track tables, views, relationships, and quickly scaffold out your metadata by using the
Hasura VS Code extension. For ease, we'll create all of our models' metadata in a single file called `allModels.hml`.
Create this file in the `/subgraphs/default/models` directory.

Bring up the command palette again, type `hasura track all` and choose the option from the dropdown. Then, select your
data source's name and, viola ‚Äî your metadata file will be populated with **models** and everything you need to get
started! üéâ

<Thumbnail src="/img/get-started/0.0.1_vs-code-track-everything.png" alt="Execute a query" width="1000px" />

:::info What are models?

This is the first new concept we've introduced in this guide. Models are a new way to represent your data in Hasura.

Models in the [OpenDD Spec](/data-domain-modeling/overview.mdx) refer to a collection of objects (such as rows in a
relational database, or documents in a NoSQL database) of a given OpenDD Spec [type](/data-domain-modeling/types.mdx).
Models are backed by a data source and can support CRUD operations. You can learn more about models
[here](/data-domain-modeling/models.mdx).

Ideally, you'll want to separate out each model into its own file. However, for the sake of this guide, we've kept them
all in one file.

:::

## Step 5: Create a new build

From the root of the project, create a build using the following command:

```bash
hasura3 build create -d "Connect Datasource and track entities"
```

The CLI will return:

```
+---------------+------------------------------------------------------------+
| Build ID      | <BUILD_ID>                                                 |
+---------------+------------------------------------------------------------+
| Build Version | <BUILD_VERSION>                                            |
+---------------+------------------------------------------------------------+
| Build URL     | https://<PROJECT_NAME_AND_BUILD_ID>.ddn.hasura.app/graphql |
+---------------+------------------------------------------------------------+
| Project Id    | <PROJECT_ID>                                               |
+---------------+------------------------------------------------------------+
| Console Url   | https://console.hasura.io/project/<PROJECT_NAME>/graphql   |
+---------------+------------------------------------------------------------+
| FQDN          | <PROJECT_NAME_AND_BUILD_ID_STUB>.ddn.hasura.app            |
+---------------+------------------------------------------------------------+
| Environment   | default                                                    |
+---------------+------------------------------------------------------------+
| Description   | Connect Datasource and track entities                      |
+---------------+------------------------------------------------------------+
```

We'll use this information in the next step to test our API!

:::info What's a build?

Builds are a new concept in Hasura that allow you to quickly iterate and prototype on your project's metadata. A build
is an immutable, fully-functioning GraphQL API that represents a milestone in your development cycle.

It may be helpful to think of builds as git commits. Since each is deployed on Hasura DDN, it can be shared with other
users.

Each build is completely independent. One project can have multiple builds, out of which, one is applied to production.
This workflow allows for easier rollbacks on production, and greater collaboration during development.

:::

## Step 6: Run your first query

Assuming you have some tables and data in your database, you can now run your first query! Head to the
[Console](https://console.hasura.io) URL returned by the CLI in the previous step. You'll be prompted to log in. Once
you're logged in, you'll be taken to the GraphiQL Explorer, where you can execute queries against your API.

We're using the docs sample app's schema for this guide's visuals, but you can use the GraphiQL Explorer to create your
query or write it manually:

<Thumbnail src="/img/get-started/0.0.1_console-execute-query-on-build.png" alt="Execute a query" width="1000px" />

<details>
<summary>Using our sample db? You can use this query!</summary>

```graphql
query OrdersQuery {
  orders {
    id
    status
    delivery_date
    user {
      id
      name
      email
    }
    product {
      id
      name
    }
  }
}
```

</details>

## Step 7: Apply your build

To apply a build using the CLI, run the following command:

```bash
hasura3 build apply --project <PROJECT_NAME> --version <BUILD_VERSION>
```

:::tip Quickly find information for projects and builds!

You can use the following command to list your projects:

```bash
hasura3 projects list
```

You can use the following command to list your builds for the current project:

```bash
hasura3 build list
```

:::

:::info What does it mean to apply a build?

Applying a build means that it's being promoted to your project's endpoint. **This is a new concept in Hasura which
allows you to quickly iterate ‚Äî and, if needed, roll back ‚Äî your project's metadata to all of your users, worldwide.**

:::

## Step 8: Query your production endpoint

At the top of the Console, you'll see a toggle that allows you to switch between your project's API and your project's
currently selected preview build. Toggle to your project's applied build:

<Thumbnail src="/img/get-started/0.1.1_console-view-project-graphiql.png" alt="Toggle production" width="1000px" />

You can now execute a query against this endpoint.

At this point, you have a fully-fledged GraphQL API that you can use to build your application. But, you also probably
need to include some business logic. With Hasura, you can incorporate _any_ TypeScript function into your API.

## Step 9: Incorporate custom business logic

We'll begin by creating a `/functions` directory in the root of our project. Then, we'll create a new file called
`index.ts` in this directory. This file will contain a simple hello world function including a JSDoc comment:

```typescript
// functions/index.ts

/**
 * Tells you Hello World!
 *
 * @returns {string} Hello World!
 * @pure This function should only query data without making modifications
 */
export function helloWorld() {
  return "Hello World!";
}
```

We'll use the [TypeScript connector](https://github.com/hasura/ndc-typescript-deno) to serve this function. For testing,
we can run this locally using the Hasura CLI, or deploy it to Hasura DDN so it's available to all of our users.

<Tabs groupId="deployment-type" className="api-tabs">
<TabItem value="local" label="Local Development">

Choosing this route will allow you to test your function locally before deploying it to Hasura DDN. This is great for
development and testing, but shouldn't be used in production.

:::info Install Deno

Before proceeding, ensure you have [Deno installed](https://docs.deno.com/runtime/manual/getting_started/installation).

:::

#### Step 1: Create a `config.json` in the root of your project

Create a `config.json` file in the root of your project. This file will contain the configuration for your function:

```json
{
  "functions": "./functions/index.ts",
  "vendor": "./vendor",
  "preVendor": true,
  "schemaMode": "INFER"
}
```

#### Step 2: Run the function locally

Run the following command to start the TypeScript connector:

```bash
deno run -A --watch --check https://deno.land/x/hasura_typescript_connector/mod.ts serve --configuration ./config.json
```

#### Step 3: Use the local server to scaffold your metadata

Create a new `hml` file in your `/subgraphs/default/commands` directory. We'll call this file `commands.hml`. You can
run `DataConnector` with the auto-complete using the VS Code extension to create the template for you:

```yaml
kind: DataConnector
version: v1
definition:
  name: commandconnector
  url:
    singleUrl: "http://0.0.0.0:<PORT>"
```

Then, from the `commands.hml` file, refresh your `commandconnector` data source using the VS Code extension:

```bash
Hasura Refresh data connector
```

You should see the schema appear in your metadata:

```yaml
kind: DataConnector
version: v1
definition:
  name: commandconnector
  url:
    singleUrl: "http://0.0.0.0:<PORT>"
  # highlight-start
  schema:
    scalar_types:
      String:
        aggregate_functions: {}
        comparison_operators: {}
        update_operators: {}
    object_types: {}
    collections: []
    functions:
      - name: helloWorld
        description: Tells you Hello World!
        arguments: {}
        result_type:
          type: named
          name: String
    procedures: []
  # highlight-end
```

You can now import the command and permissions by running the following command via the VS Code extension:

```bash
Hasura Track all collections...
```

Which will add the following to your metadata:

```yaml
---
kind: Command
version: v1
definition:
  name: helloWorld
  outputType: String!
  arguments: []
  source:
    dataConnectorName: commandconnector
    dataConnectorCommand:
      function: helloWorld
  graphql:
    rootFieldKind: Query
    rootFieldName: helloWorld

---
kind: CommandPermissions
version: v1
definition:
  commandName: helloWorld
  permissions:
    - role: admin
      allowExecution: true
```

:::info Why are we using the local server?

In the next step, we'll create a Secure Connect tunnel that is only accessible via Hasura DDN. However, we need to
scaffold our metadata using a local server. This is because the VS Code extension needs to introspect your function's
schema to populate your metadata.

Improvements for this workflow are on our roadmap.

:::

#### Step 4: Start the daemon

Start the Hasura daemon with the `daemon start` command:

```bash
hasura3 daemon start
```

#### Step 5: Create a Secure Connect tunnel

Open a new tab or window for your terminal and run the `create` command:

```bash
hasura3 tunnel create <SOCKET>
```

:::info Which socket should I use?

The `<SOCKET>` argument is the address on which your local function is running. From **Deno**, you should see an output,
for example, of `Server listening at http://0.0.0.0:8100`.

:::

The CLI will return an endpoint that you can use to connect to your function:

```bash
Creating tunnel... ok
Tunnel active on URL <TUNNEL_ENDPOINT>
```

In the next step, you'll use this endpoint to form a connection string for your function, like this:

```text
http://<TUNNEL_ENDPOINT>
```

#### Step 6: Create a new build

From the root of the project, create a build using the following command:

```bash
hasura3 build create -d "Add custom business logic"
```

If you navigate to your Console, you should see your `helloWorld` function appear in the GraphiQL Explorer as part of
your API üéâ

<Thumbnail src="/img/get-started/0.1.1_console_ts-hello-world.png" alt="Use a TS function in your api" width="1000px" />

This function will continue to work so long as the TypeScript connector is running and your tunnel is active. If you
want to deploy this function to Hasura DDN, check out the other tab in this modal.

</TabItem>
<TabItem value="deployed" label="Deployed to Hasura DDN">

Choosing this route will allow you to deploy your function to Hasura DDN so it's available to all of your users. We take
care of the infrastructure for you, so you can focus on building your application.

#### Step 1: Install the `connector` plugin

We'll install the `connector` plugin for the Hasura CLI using this command:

```bash
hasura3 plugins install connector
```

#### Step 2: Deploy the connector

```bash
hasura3 connector create <NAME_FOR_CONNECTOR> \
  --github-repo-url https://github.com/hasura/ndc-typescript-deno/tree/main \
  --config-file <(echo '{}') \
  --volume ./functions:/functions \
  --env SERVICE_TOKEN_SECRET=MY-SERVICE-TOKEN # (optional)
```

You can monitor the deployment status of the connector using the following command:

```bash
hasura3 connector status <NAME_FOR_CONNECTOR>
```

When it's ready, you can run the following command to get the URL for your function:

```bash
hasura3 connector list
```

#### Step 3: Add the connector as a data source

Create a new `hml` file in your `/subgraphs/default/commands` directory. We'll call this file `commands.hml`. You can
run `DataConnector` with the auto-complete using the VS Code extension to create the template for you:

```yaml
kind: DataConnector
version: v1
definition:
  name: commandconnector
  url:
    singleUrl: "<TUNNEL_URL>"
```

Then, from the `commands.hml` file, refresh your `commandconnector` data source using the VS Code extension:

```bash
Hasura Refresh data connector
```

You should see the schema appear in your metadata:

```yaml
kind: DataConnector
version: v1
definition:
  name: commandconnector
  url:
    singleUrl: "<TUNNEL_URL>"
  # highlight-start
  schema:
    scalar_types:
      String:
        aggregate_functions: {}
        comparison_operators: {}
        update_operators: {}
    object_types: {}
    collections: []
    functions:
      - name: helloWorld
        description: Tells you Hello World!
        arguments: {}
        result_type:
          type: named
          name: String
    procedures: []
  # highlight-end
```

You can now import the command and permissions by running the following command via the VS Code extension:

```bash
Hasura Track all collections...
```

Which will add the following to your metadata:

```yaml
---
kind: Command
version: v1
definition:
  name: helloWorld
  outputType: String!
  arguments: []
  source:
    dataConnectorName: commandconnector
    dataConnectorCommand:
      function: helloWorld
  graphql:
    rootFieldKind: Query
    rootFieldName: helloWorld

---
kind: CommandPermissions
version: v1
definition:
  commandName: helloWorld
  permissions:
    - role: admin
      allowExecution: true
```

#### Step 4: Create a new build

From the root of the project, create a build using the following command:

```bash
hasura3 build create -d "Add custom business logic"
```

If you navigate to your Console, you should see your `helloWorld` function appear in the GraphiQL Explorer as part of
your API üéâ

<Thumbnail src="/img/get-started/0.1.1_console_ts-hello-world.png" alt="Use a TS function in your api" width="1000px" />

</TabItem>
</Tabs>

### What can you do with this?

Well, these TypeScript functions can be used to incorporate any business logic you need or bring existing microservices
into your API. If your backend needs to do it, or you need to connect to a third-party API, you can do it with Hasura.

## What's next?

### Iterate on your metadata

We've just demonstrated how to quickly get set up and running with Hasura. Now that you've got a project up and running,
you can iterate on your metadata and build out your API. Head back to your IDE, make some modifications, create a new
build, and see what happens üéâ

Learn more about structuring your data supergraph by checking out our
[Data Domain Modeling](/data-domain-modeling/overview.mdx) section.
