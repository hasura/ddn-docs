---
title: Add business logic
sidebar_label: "Step 2. Add business logic"
sidebar_position: 3
description: "Learn how to add custom business logic to your API."
keywords:
  - hasura ddn
  - graphql api
  - quickstart
  - getting started
  - guide
  - business logic
  - typescript
---

import Thumbnail from "@site/src/components/Thumbnail";

# Add Business Logic

## Introduction

With DDN, Hasura introduces a new way of writing custom business logic using the the TypeScript connector. This exposes
functions or procedures that can be added to Hasura metadata as a [command](/supergraph-modeling/commands.mdx), which
can be made available over your GraphQL API as a query or a mutation.

## Step 1: Navigate to the TypeScript connector

When we ran `ddn quickstart`, we told the CLI we wanted to include the TypeScript connector; inside of the
`/app/app_functions` directory, we can find all the files the CLI generated, including `functions.ts` which will house
our custom logic:

```bash
â”œâ”€â”€ builds
# highlight-start
â”‚   â”œâ”€â”€ functions.ts
# highlight-end
â”‚   â”œâ”€â”€ package-lock.json
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ app_functions.build.hml
â”‚   â””â”€â”€ tsconfig.json
â””â”€â”€ app_functions.hml
```

If we open `functions.ts`, we'll see the following contents:

```ts
/**
 * @readonly Exposes the function as an NDC function (the function should only query data without making modifications)
 */
export function hello(name?: string) {
  return `hello ${name ?? "world"}`;
}
```

We can use this in our API by running the following query:

```graphql
query MyQuery {
  hello(name: "Hasura")
}
```

Which should return:

```JSON
{
  "data": {
    "hello": "hello Hasura"
  }
}
```

## Step 2: Make some changes

Since we're running `ddn dev`, the CLI generated a tunnel between this locally running TypeScript connector and our API
hosted on Hasura DDN. This means any changes we make will trigger a new build and instantly be available via our API.
Let's modify `hello()` to the following:

```ts
/**
 * @readonly Exposes the function as an NDC function (the function should only query data without making modifications)
 */
export function hello(name?: string) {
  return `Hello, ${name ?? "World"}! ðŸ‘‹`;
}
```

Now, if we re-run our query, we should see nearly the same message...just with a bit more gusto!

```JSON
{
  "data": {
    "hello": "Hello, Hasura! ðŸ‘‹"
  }
}
```

## Step 3: Create and track a new function

Of course, our API will need more than one function. Let's create a new function called `scoldUser()` inside
`functions.ts` that yells at a user if they do something they're not supposed to do:

```ts
/**
 * @readonly
 */
export function scoldUser(userId: string) {
  return `DON'T DO THAT, ${userId}!`;
}
```

We need to make sure our connector is aware of this function by tracking it. If we look inside our `app_functions.hml`
file, we'll see the key-value pair with a warning for our new function. If we hover over the warning line, we can use
code actions (quick fix) to track the new function and add it to our API:

<Thumbnail src="/img/get-started/0.0.1_vs-code_track-new-function.png" alt="Tracking new function" width="1000px" />

:::info Storing tracked functions

After selecting this code action, the extension will ask you where you'd like to save the metadata for `scoldUser()`.
Choose the `Default` option to store it in its own file for ease and organization. This will create a new file in
`commands` called `scoldUser.hml`.

:::

:::danger HEY!

NOT YET READY VIA CLI â€” IF YOU'RE FOLLOWING ALONG FOR TESTING, KILL DEV MODE AND RESTART IT TO HAVE THE NEW COMMAND BE
AVAILABLE IN YOUR API

:::

This will trigger a rebuild of our connector and our new function will instantly be available in our API. We can test it
by running the following query:

```graphql
query MyQuery {
  scoldUser(userId: "7cf0a66c-65b7-11ed-b904-fb49f034fbbb")
}
```

<Thumbnail src="/img/get-started/0.0.1_console_run-scoldUser.png" alt="Scold a user" width="1000px" />

## Step 4: Import a package

The TypeScript connector acts like any NodeJS project; this means you can use all the packages you're already familiar
with. Let's add the `pg` package so we can directly interact with our database.

Inside the `/app/app_functions/builds` directory, run the following:

```bash
npm i pg
npm i --save-dev @types/pg
```

Update your `functions.ts` file to read as follows:

```ts
import { Client } from "pg";

/**
 * @readonly Exposes the function as an NDC function (the function should only query data without making modifications)
 */
export function hello(name?: string) {
  return `Hello, ${name ?? "World"}! ðŸ‘‹`;
}

/**
 * @readonly
 */
export async function scoldUser(userId: string) {
  // Yes, for ease we're reusing the same sample app ðŸ˜‰
  const client = new Client({
    host: "35.236.11.122",
    port: 5432,
    database: "v3-docs-sample-app",
    user: "read_only_user",
    password: "readonlyuser",
  });

  await client.connect();

  const queryText = "SELECT name FROM users WHERE id = $1";
  const result = await client.query(queryText, [userId]);

  if (result.rows.length > 0) {
    const userName = result.rows[0].name;
    return `DON'T DO THAT, ${userName.toUpperCase()}!`;
  } else {
    return `Issue retrieving user`;
  }
}
```

We'll use this to determine who our user is and scold them by name.

After modifying the `functions.ts` file, re-run the same query in your API and you should see the following returned:

```json
{
  "data": {
    "scoldUser": "DON'T DO THAT, SEAN!"
  }
}
```

## Step 5: Create a relationship

It would be nice to call this function as part of a larger query for a user. We can create relationships **directly**
between our commands and models. That means we can call `scoldUser` directly on Sean from our API without requiring
additional queries, and â€” if we'd like â€” can even return other related data.

Find the `users.hml` file in `/app_connector/models` and add a new entry at the bottom of the file by adding `---` and
hitting `ENTER`.

Once you hit enter, you should see Hasura's LSP kick in and provide you with the variety of options of new metadata
objects you can add. If you start typing `relationship`, choose the `Relationship (to command)` option, and hit `ENTER`,
the LSP will scaffold out your metadata object.

<Thumbnail src="/img/get-started/0.0.1_vs-code_add-relationship.png" alt="Add a relationship" width="1000px" />

You can tab through each key-value pair; the LSP will assist you by returning available options based on your data
sources. Your final relationship should look like this:

```yaml
---
kind: Relationship
version: v1
definition:
  name: scold_user
  source: users
  target:
    command:
      name: scoldUser
  mapping:
    - source:
        fieldPath:
          - fieldName: id
      target:
        argument:
          argumentName: userId
```

Upon saving the file, your API will be re-built. If you head to your project's console and run the following query, you
can directly call your TypeScript function from your API based on your user's ID:

```graphql
query MyQuery {
  users(where: { id: { _eq: "7cf0a66c-65b7-11ed-b904-fb49f034fbbb" } }) {
    scold_user
  }
}
```

And the response is:

```JSON
{
  "data": {
    "users": [
      {
        "scold_user": "DON'T DO THAT, SEAN!"
      }
    ]
  }
}
```

## Step 6: Add permissions

Of course, we don't want _any_ user accessing this command from the API. With both models and commands, we can
declaratively restrict access to specific roles using permissions.

Find the `scoldUser.hml` file in `/app/app_functions/commands` and let's use the LSP to help us create a permission.
Within this file, you'll see `CommandPermissions` for `scoldUser` command. There's already a permissions array with the
role of `admin` enabled by default.

<Thumbnail
  src="/img/get-started/0.0.1_vs-code_existing-user-permissions.png"
  alt="Default command permissions"
  width="1000px"
/>

Let's add a new item to the array for a `user` role and disallow execution:

```yaml
---
kind: CommandPermissions
version: v1
definition:
  commandName: scoldUser
  permissions:
    - role: admin
      allowExecution: true
    - role: user
      allowExecution: false
```

If you head back to your API, you can add the following key-value pair to test our new permission:

| Key             | Value  |
| --------------- | ------ |
| `x-hasura-role` | `user` |

This header tells your API that the request is being made by someone with the role of `user`. That role's access-control
rules are then evaluated against your metadata resulting in whether or not that role has access to the requested
resource.

<Thumbnail
  src="/img/get-started/0.0.1_console_disallowed_roles.png"
  alt="Console with disallowed roles"
  width="1000px"
/>

## What just happened?

We learned a lot!

First, we introduced you to a quick and easy way of adding custom business logic to your API. Hasura can host your
TypeScript connector for you, or you can host it yourself. You can learn more about the connector and deployment options
to Hasura DDN or self-hosted solutions by visiting [this page](/connectors/deployment).

We saw that as this connector uses NodeJS under the hood, we can utilize any existing `npm` package for working with and
enriching data before returning it to our end users.

Finally, we learned that with the **superpower** of LSP-assisted metadata authoring, we can intuitively and
declaratively create relationships and permissions to use these functions in concert with models present in our
**supergraph** ðŸ¤¯

For our final step in this getting started guide, let's add a second subgraph with a data source to truly make this a
supergraph.
