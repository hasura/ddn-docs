---
sidebar_position: 10
sidebar_label: Add permissions
description: "Learn how to get started with Hasura DDN and your GraphQL API."
keywords:
  - hasura ddn
  - graphql api
  - quickstart
  - getting started
  - guide
---

import Thumbnail from "@site/src/components/Thumbnail";

# Add Permissions

## What's about to happen?

If you've already created and tested your supergraph, you'll have seen that queries are executed by default using the
`admin` role. However, you can easily add authorization rules — what we term permissions — by simply using the same
declarative metadata approach you can use for relationships and versioning. This allows you to control what data can be
accessed and what fields can be returned by your API based on the user role, or any other value in session variables.

In the steps below, we'll add
[`modelPermissions`](/supergraph-modeling/permissions.mdx#modelpermissions-modelpermissions) to filter the data that can
be accessed by a role and [`typePermissions`](/supergraph-modeling/permissions.mdx#typepermissions-typepermissions) to
control what fields are returned by your API.

We will then test these permissions by creating a JWT token with the role of `user` and a specific `id` value, and
passing this token in the `Auth-Token` header of our request.

:::tip You can use the Hasura VS Code extension!

You can use the Hasura VS Code extension to help you author any metadata objects or updates, including
`modelPermissions` and `typePermissions`. You can activate its autocomplete abilities using `CTRL+SPACEBAR` inside of
any `hml` file.

:::

<Thumbnail src="/img/get-started/ERD/add-auth.png" alt="Add authorization to your API" width="1000px" />

## Steps

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [project](/getting-started/deployment/01-create-a-project.mdx)
- At least one [subgraph](/getting-started/build/02-init-subgraph.mdx)
- At least one [data connector running](/getting-started/build/03-connect-to-data/01-connect-a-source.mdx)
- [Models and/or Commands added](/getting-started/build/03-connect-to-data/02-create-source-metadata.mdx) to your
  subgraph

:::

### Step 1. Get a User ID to test your permissions

We'll be creating a set of permissions in our metadata which effectively says: _"Only allow users to access certain
fields of their own data"._

To test this, if you want to follow along in your own project, we'll first need to know the `id` of a user in your
own data source so the permission can filter results for them. You can find this by running a query in the console
for a user ID. Copy it. We'll use this value in the JWT we're going to create.


### Step 2. Create a modelPermission

By default, a role of `admin` exists for your API and can access all models. To create a new role, such as `user`,
simply add the role to the list of `permissions` for a model and set up your access control rules. In the example below,
we'll allow users with the role of `user` to access only their own rows from a `Users` model by checking for a header
value matching their `id`:

```yaml title="For example, in a Users.hml"
---
kind: ModelPermissions
version: v1
definition:
  modelName: Users
  permissions:
    - role: admin
      select:
        filter: null
        #highlight-start
    - role: user
      select:
        filter:
          fieldComparison:
            field: id
            operator: _eq
            value:
              sessionVariable: x-hasura-user-id
        #highlight-end
```

:::tip Where are models?

Remember, models are under the `metadata` subdirectory under the subgraph directory.

:::

### Step 3. Create a typePermission

The `admin` role also has access to all fields for each model. However, adding a new role and limiting what columns can
be returned from your data source is just as simple. For example, let's restrict what a `user` can see by omitting
several fields from the `typePermissions`:

```yaml title="For example, in a Users.hml"
---
kind: TypePermissions
version: v1
definition:
  typeName: Users
  permissions:
    - role: admin
      output:
        allowedFields:
          - createdAt
          - email
          - favoriteArtist
          - id
          - isEmailVerified
          - lastSeen
          - name
          - password
          - updatedAt
    #highlight-start
    - role: user
      output:
        allowedFields:
          - email
          - favoriteArtist
          - id
          - name
          - password
    #highlight-end
```

### Step 4. Create a JWT token

In a production environment, you would be creating JWT tokens using your authentication provider or custom
business logic solution. We're going to use the `jwt-cli` to encode and generate a new token with the different claims
to run a test of our new permissions.

Install the [`jwt-cli`](https://github.com/mike-engel/jwt-cli), which allows you to generate tokens from the command
line. You can follow their list of installation instructions found
[here](https://github.com/mike-engel/jwt-cli?tab=readme-ov-file#installation).


### Step 5. Generate a random string

Generate a random string that we'll use as the JWT secret key:

Copy the value returned by the terminal.

:::info Creating a random string

If you don't want to use openssl, you can use any other random string generators. The only requirement is that the
string must be at least 32 characters.

:::


### Step 6. Set up your AuthConfig object

Set up an `AuthConfig` object in your project which uses this secret key.

```yaml title="In globals/auth-config.hml:"
kind: AuthConfig
version: v1
definition:
  allowRoleEmulationBy: admin
  mode:
    jwt:
      claimsConfig:
        namespace:
          claimsFormat: Json
          location: "/https:~1~1hasura.io~1jwt~1claims"
      key:
        fixed:
          algorithm: HS256
          key:
            value: "<insert-the-key-generated-in-previous-step>"
      tokenLocation:
        type: Header
        name: Auth-Token
```

### Step 7. Create a new supergraph build

Create a supergraph build using this `AuthConfig`.

```bash
ddn supergraph build local
```

:::tip Start your engines!

Want to test your supergraph? Don't forget to start your GraphQL engine and connectors using the following command.

```bash title="Run:"
HASURA_DDN_PAT=$(ddn auth print-pat) docker compose --env-file .env up --build --watch
```

**If you haven't [included your connector(s)](/getting-started/build/01-init-supergraph.mdx) in your `compose.yaml`,
don't forget to start it as well.**

:::

### Step 8. Generate a JWT

For this test we'll use `jwt-cli` to encode and generate a new token with our claims.

```bash title="Run the following in your terminal:"
jwt encode \
  --secret="<secret-key>" \
  '{
    "exp": 1739905122,
    "iat": 1708369122,
    "https://hasura.io/jwt/claims": {
      "x-hasura-default-role": "user",
      "x-hasura-allowed-roles": ["user"],
      "x-hasura-user-id": "<insert-the-id-of-a-user-in-your-data-source>"
    }
  }'
```

Copy the token value returned by the terminal.

In the example above, we're setting the following values:

- The issued (`iat`) time as `Feb. 19 2024, at 18:58:42` as a Unix epoch timestamp.
- The expiration (`exp`) time as `Feb. 18, 2025 at 18:58:42`.
- The default role as `user`.
- The allowed roles as `user`
- The `x-hasura-user-id` value as the `id` of a user in your data source.

For more information about the claims Hasura expects, check out [this page](/auth/authentication/jwt/setup.mdx).

Note that in our `AuthConfig` object, we've set the token location to be in the header `Auth-Token`. This means that
when we test our permissions, we'll need to pass the JWT token value in that header in our request.

### Step 9: Test your permissions with a custom JWT

In the Hasura console, add the JWT generated by the console as the value of a new header called `Auth-Token` on the
`GraphiQL` tab.

IMAGE

Now, you can execute queries with your custom JWT. For example, you can run a query to get the user's email:

```graphql
query PermissionTest {
  app_users {
    id
    email
    favoriteArtist
    name
    password
  }
}
```

### Step 10. Check the results

If you've followed the steps correctly, you should see only the email of the user you've tested with.

<Thumbnail
  src="/img/get-started/beta/console-query-with-permissions.png"
  alt="Query with authorization"
  width="1000px"
/>

## What did this do?

By adding `modelPermissions`, we've enabled access to the `Users` model for the `user` role. This means that _only_
the `Users` model is available to a consumer with the `x-hasura-role` value of `user`.

Additionally, `modelPermissions` are used to filter the rows that can be returned from this model. They don't simply
check if the returned data is allowed; instead, they filter the data before it can be returned. In our example, this is
achieved by validating the `x-hasura-user-id` value against the matching record with the same `id` in the data source.

Finally, we limited the fields they can access to the ones listed above, thereby preventing someone with the `user` role
from accessing information not meant for them, such as when users were last seen.

We've then encoded a test JWT token with the `user` role and `x-hasura-user-id` value of a user in our data
source. We've passed this token in the `Auth-Token` header to test our permissions, which we've set up to allow only the
`Users` model to be accessed by a user with the `user` role.

## What's next?

In a production environment, you would be creating JWT tokens using your authentication provider or custom business
logic and passing them in the `Auth-Token` header of your requests.

We recommend you keep going and check out the
[custom business logic section](/getting-started/build/06-add-business-logic.mdx) next.
