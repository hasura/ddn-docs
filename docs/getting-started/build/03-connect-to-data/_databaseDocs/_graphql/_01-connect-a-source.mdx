import Thumbnail from "@site/src/components/Thumbnail";

## What's about to happen?

You can easily and quickly connect any GraphQL API to your supergraph.

To do this, we use the Hasura [GraphQL Native Data Connector](https://github.com/hasura/ndc-graphql) to facilitate the
connection.

<Thumbnail src="/img/get-started/ERD/connect-data.png" alt="Connect a data source" width="1000px" />

## Step 1. Initialize the GraphQL connector

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [supergraph](/getting-started/build/01-init-supergraph.mdx)
- A new or existing [subgraph](/getting-started/build/02-init-subgraph.mdx)

:::

To initialize the GraphQL connector, run the following in your terminal:

```bash
ddn connector init my_graphql \
  --hub-connector hasura/graphql \
  --configure-port 8087 \
  --add-to-compose-file compose.yaml
```

With this `connector init` command, we're passing a few important values.

**Connector name**

We're naming the connector `my_graphql` in this example, but you can call it whatever makes sense to you. For example,
if this connector is integrating a GraphQL API from a content management service (CMS), it would make sense to name it
something like `content`.

**Subgraph: `--subgraph`**

We're specifying the subgraph config file that this connector will be added to using the `--subgraph` flag.

**Connector: `--hub-connector`**

We're specifying that this connector should be the: `hasura/graphql`, connector listed in the
[Connector Hub](https://hasura.io/connectors/graphql).

**Port: `configure-port`**

We're specifying the port to run the connector on. This is important to avoid port collisions with other connectors or
services which you might have running on your machine. Remember to use a different port for each connector or service
you may have running.

**Compose file: `--add-to-compose-file`**

We're specifying the `--add-to-compose-file` flag to add the connector's **own** Docker compose file to the main
`compose.yaml` file. This is for convenience and allows us to start the Hasura Engine and connectors together.

:::tip Best practices

Importantly, a data connector can only connect to one data source.

The project will be kept organized with each data connector's configuration located in a relevant subgraph directory. In
this example the CLI will create a `my_subgraph/connector/my_graphql` directory if it doesn't exist. You can also change
this directory by passing a `--dir` flag to the CLI.

We recommend that the name of the connector and the directory in which the configuration is stored, `my_graphql` in this
example, should match for convenience and clarity sake for this tutorial, but it can be anything you want.

In subsequent steps, when running your connector locally, it's critical to ensure the port value matches the connection
string you provide in your subgraph's `.env.my_subgraph` file.

:::

### What did `connector init` do?

In the `my_subgraph/connector/my_graphql` directory which we specified in the command, the CLI created:

- A `connector.local.yaml` file which contains the local configuration for the connector.
- A `connector.cloud.yaml` file which contains the cloud configuration for the connector.
- A `configuration.json` file which contains the connector' configuration.
- A `configuration.schema.json` file which will contain information about the API's schema.
- A `.hasura-connector/connector-metadata.yaml` file which contains extra metadata for the connector.
- A placeholder `.ddnignore` file to prevent unnecessary files from being included in the build.
- A `compose.yaml` file which includes the connector's Docker compose file.
- An `.env.local` placeholder file for environment variables for pertaining to running this connector locally.
- An `.env.cloud` file for environment variables for pertaining to running this connector in the cloud.

Right now, the CLI has only scaffolded out configuration files for the data connector. Our connector still knows nothing
about the GraphQL API's schema. That's coming up in the next steps.

## Step 2. Configure the roles

### Step 2.1 Configure introspection

Under the `introspection` section, add the URL for your GraphQL endpoint.

```json title="Inside of my_subgraph/connector/my_graphql/configuration.json:"
{
  ...
  "introspection": {
    "endpoint": {
      //highlight-start
      "value": "https://my-graphql-endpoint/graphql"
      //highlight-end
    }
  }
}
```

:::tip Connecting to an Existing Hasura v2 Instance

When connecting to an existing Hasura v2 instance, it is important to update the configuration introspection with the
appropriate headers: `x-hasura-admin-secret` and `x-hasura-role`. These headers are necessary for executing
introspection requests successfully.

You may want to set a pre-defined value for `x-hasura-role` to ensure that introspection occurs under a specific role.
This can be particularly useful if you want requests to be executed without requiring forwarded authentication
credentials.

**Caution:** If no explicit role is set, the admin role will be used to fetch the schema. This may not be suitable for
your application.

There are some other considerations for connecting to a v2 instance. For more details, please visit
[the connector's repository](https://github.com/hasura/ndc-graphql).

:::

### Step 2.2 Configure execution

Under the `execution` section, add the URL for your GraphQL endpoint.

```json title="Inside of my_subgraph/connector/my_graphql/configuration.json:"
{
  ...
  "execution": {
    "endpoint": {
      //highlight-start
      "value": "https://my-graphql-endpoint/graphql"
      //highlight-end
    }
  }
}
```

## Step 3. Introspect your GraphQL API

This will introspect your GraphQL API and fetch all the required information for your connector.

```bash
ddn connector introspect --connector my_subgraph/connector/my_graphql/connector.local.yaml
```

:::tip Remove placeholder environment variables

If your API doesn't have authorization, or if you haven't set `GRAPHQL_ENDPOINT_AUTHORIZATION`, remove these values from
your config. Otherwise, introspection will fail.

:::

## What did `connector introspect` do?

We specify the connector that we want to introspect with the `--connector` flag and provide it with the location of that
`connector.local.yaml` configuration file.

The CLI will introspect the introspect the GraphQL schema and create a `schema.graphql` file in the
`my_subgraph/connector/my_graphql` directory. This schema is a representation of your external GraphQL API.

:::tip o11y via OpenTelemetry

Yes! Connectors ship with OTEL-enabled tracing available, out of the box ðŸŽ‰

:::

## Step 4. Restart the services

Let's restart our docker compose services so that Docker can create a GraphQL connector build for us now that we've
added and introspected the connector. **If you have existing services running, bring them down using
`docker compose down` or `CTRL` + `C` if your terminal tab is still actively logging information.**

```bash title="Run:"
HASURA_DDN_PAT=$(ddn auth print-pat) docker compose up --build --watch
```

This starts our Hasura Engine, observability tools and the GraphQL connector all together since we added the connector's
Docker compose file to the main `compose.yaml` file using the `--add-to-compose-file` flag when we initialized the
connector. `HASURA_DDN_PAT=$(ddn auth print-pat)` gives the Hasura Engine access to the DDN CLI's authentication token.

We can navigate to the following address, with the port modified, to see the schema of our GraphQL API:

```text
http://localhost:8087/schema
```

## Next steps

With these files, which represent the GraphQL API, we can now use it to
[generate Hasura metadata](/getting-started/build/03-connect-to-data/02-create-source-metadata.mdx).
