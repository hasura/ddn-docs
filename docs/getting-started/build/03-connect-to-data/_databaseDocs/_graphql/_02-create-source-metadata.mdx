import Thumbnail from "@site/src/components/Thumbnail";

## What's about to happen

Now that we a configuration which represents the GraphQL API, we can now use it to generate Hasura metadata.

<Thumbnail src="/img/get-started/ERD/create-metadata.png" alt="Create source metadata" width="1000px" />

## Step 1. Create the Hasura metadata

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [supergraph](/getting-started/build/01-init-supergraph.mdx)
- A new or existing [subgraph](/getting-started/build/02-init-subgraph.mdx)
- A [GraphQL connector](/getting-started/build/03-connect-to-data/01-connect-a-source.mdx) initialized

:::

Hasura DDN uses a concept called "connector linking" to take configuration files from a data connector and transform
them into an [NDC-compliant](https://github.com/hasura/ndc-spec) `hml` (Hasura Metadata Language) file as a
[DataConnectorLink](/supergraph-modeling/data-connector-links/) metadata object.

Let's name the `DataConnectorLink` `hml` file the same as our connector, `my_graphql`:

```bash title="Run the following from the root of your project:"
ddn connector-link add my_graphql \
  --subgraph my_subgraph/subgraph.yaml \
  --configure-host http://local.hasura.dev:8087 \
  --target-env-file my_subgraph/.env.my_subgraph.local
```

The new file is scaffolded out at `my_subgraph/metadata/my_graphql/my_graphql.hml`.

:::info JSON and HML, why both?

Basically, metadata objects in `hml` files contain the data connector schema in a
[format](https://github.com/hasura/ndc-spec) which is generic for all connectors. The JSON on the other hand contains a
format specific to that connector. It does not need to be JSON, it could just as easily be SQL files, TypeScript
functions, or anything else. It's just a representation that the specific connector understands.

:::

<details>
  <summary>Click here for an example `hml` `DataConnectorLink` file</summary>

```yaml
kind: DataConnectorLink
version: v1
definition:
  name: my_graphql
  url:
    readWriteUrls:
      read:
        valueFromEnv: MY_SUBGRAPH_MY_GRAPHQL_READ_URL
      write:
        valueFromEnv: MY_SUBGRAPH_MY_GRAPHQL_WRITE_URL
  schema:
    # This is read from the connector schema configuration
  argumentPresets:
    - argument: headers
      value:
        httpHeaders:
          forward:
            - X-Hasura-Admin-Secret
            - Authorization
          additional: {}
```

</details>

The generated file has two environment variables â€” one for reads and one for writes. Because we used the convenience
flag: `--configure-host` on the command, these values are already set in the `.env.my_subgraph` file:

```env title="Already set for you in .env.my_subgraph"
MY_SUBGRAPH_MY_GRAPHQL_READ_URL="http://local.hasura.dev:8087"
MY_SUBGRAPH_MY_GRAPHQL_WRITE_URL="http://local.hasura.dev:8087"
```

These values are for the GraphQL connector itself and utilize `local.hasura.dev` to ensure proper resolution within the
docker container.

## Step 2. Update the new DataConnectorLink object with metadata for your GraphQL API

Finally, now that our `DataConnectorLink` has the correct environment variables configured for the GraphQL connector, we
can run the `update` command to have the CLI look at config and generate our `DataConnectorLink` metadata in `hml`
format:

```bash
ddn connector-link update my_graphql \
  --subgraph my_subgraph/subgraph.yaml \
  --env-file my_subgraph/.env.my_subgraph.local
```

After this command runs, you can open the same `my_subgraph/metadata/my_graphql/my_graphql.hml` file and see your
metadata completely scaffolded out for you ðŸŽ‰

## What did this do?

By creating a `my_graphql.hml` file, we've provided Hasura with a link between our original data source and the types
which we'll eventually expose via our API.

## Next steps

With a data connector fully configured, you can now start to create metadata for each type exposed in our GraphQL schema
as `hml`. Learn how to do this by
[adding source entities](/getting-started/build/03-connect-to-data/03-add-source-entities.mdx).
