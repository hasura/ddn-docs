## Step 1. Create a function

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [supergraph](/getting-started/build/01-init-supergraph.mdx)
- A new or existing [subgraph](/getting-started/build/02-init-subgraph.mdx)
- A [MongoDB connector](/getting-started/build/03-connect-to-data/01-connect-a-source.mdx) initialized
- A [DataConnectorLink](/getting-started/build/03-connect-to-data/02-create-source-metadata.mdx) configured
- A [TypeScript connector](/getting-started/build/06-add-business-logic.mdx) configured

:::

The TypeScript connector is a regular TypeScript project. We can use any Node.js packages we want.

We'll use the `dotenv` and `mongodb` packages to access our connection string, saved as an environment variable, and to
connect to our database.

```bash title="From the my_subgraph/connector/my_mongo directory, run:"
npm i dotenv mongodb
```

### Step 2. Add the connection URI

We'll add our MongoDB connection string as an environment variable to our connector's `.env.local` file. This will allow
us to access the connection string in our function.

```env title="my_subgraph/connectors/my_mongo/.env.local"
CONNECTION_URI=<your-mongodb-connection-string>
```

### Step 3. Create a function

The TypeScript connector uses [JSDoc comments](https://jsdoc.app/) to determine how to expose a function: either as a
query or a mutation. If we include the `@readOnly` tag, it will be exposed as a query. Simply omitting this tag will
expose the function as a mutation.

We can even add documentation that will be visible in the GraphiQL explorer by tagging `@param` for the argument(s) and
`@returns` for what will be returned by the mutation.

```ts title="my_subgraph/connectors/my_ts/functions.ts"
import { MongoClient } from 'mongodb';
import dotenv from 'dotenv';

dotenv.config();

/**
 * @param productData An object containing the product's data.
 * @returns The ID of the newly inserted product.
 */
export async function insertProduct(productData: { title: string; description: string }): Promise<string> {
  const client = new MongoClient(process.env.CONNECTION_URI!, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });

  try {
    await client.connect();
    const database = client.db('yourDatabaseName'); // Replace with your database name
    const collection = database.collection('product');

    const result = await collection.insertOne({
      title: productData.title,
      description: productData.description,
    });

    if (result.insertedId) {
      return result.insertedId.toString();
    } else {
      throw new Error('Failed to insert product');
    }
  } finally {
    await client.close();
  }
}
```

## Step 2. Track the function

We'll track our function using the CLI by first updating our `DataConnectorLink` for this data connector:

```bash
ddn connector-link update my_mongo \
  --subgraph my_subgraph/subgraph.yaml \
  --env-file my_subgraph/.env.my_subgraph.local
```

And then bringing in the new command:

```bash
ddn command add --connector-link my_mongo --name insertProduct
```

## Step 3. Create a new build and test

Next, let's create a new build of our supergraph:

```bash
ddn supergraph build local \
  --output-dir engine \
  --subgraph-env-file my_subgraph:my_subgraph/.env.my_subgraph.local
```

:::tip Start your engines!

Want to test your supergraph? Don't forget to start your GraphQL engine and connectors using the following command.

```bash title="From the root of your project, run:"
HASURA_DDN_PAT=$(ddn auth print-pat) docker compose up --build --watch
```

**If you haven't [included your connector(s)](/getting-started/build/01-init-supergraph.mdx) in your
`compose.yaml`, don't forget to start it as well.**

:::

Finally, should see your command available, along with its documentation, in the GraphiQL explorer as a mutation.

<!-- TODO: Add screenshot of console -->
