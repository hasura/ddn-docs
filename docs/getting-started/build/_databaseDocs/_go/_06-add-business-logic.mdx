import Thumbnail from "@site/src/components/Thumbnail";

## What's about to happen?

With Hasura, you can integrate — and even host — business logic directly with Hasura DDN and your API.

You can handle custom business logic using the Go connector. Using this connector, you can transform or enrich data
before it reaches your consumers, or perform any other app business logic you may need.

You can then integrate these functions as individual [**commands**](/supergraph-modeling/commands.mdx) in your metadata
and resulting API. This process simplifies client applications and speeds up your backend development.

<Thumbnail src="/img/get-started/ERD/add-bizlogic.png" alt="Add business logic to your API" width="1000px" />

## Steps

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [project](/getting-started/deployment/01-create-a-project.mdx)
- At least one [subgraph](/getting-started/build/02-init-subgraph.mdx)
- [Go](https://go.dev/) version `>=1.21.0`

:::

In this guide we will:

- Initialize the `hasura/go` data connector
- Add a new `DataConnectorLink`
- Update the `DataConnectorLink` to track the function script as a command in our metadata
- Create a new API build and test it

### Step 1. Initialize the Go connector

Let's begin by initializing the connector on our project. In the example below, you'll see some familiar flags with new
values being passed to them. We'll call this `my_go` and use the `hasura/go` connector from the connector hub:

```bash title="Run the following command:"
ddn connector init -i --subgraph my_subgraph/subgraph.yaml \
  --add-to-compose-file ./compose.yaml
```

- Select `hasura/go` from the list of connectors.
- Name it something descriptive. For this example, we'll call it `my_go`.
- Choose a port (press enter to accept the default recommended by the CLI).

:::tip Best practices

Importantly, a data connector can only connect to one data source.

The project will be kept organized with each data connector's configuration located in a relevant subgraph directory. In
this example the CLI will create a `my_subgraph/connector/my_go` directory if it doesn't exist. You can also change this
directory by passing a `--dir` flag to the CLI.

We recommend that the name of the connector and the directory in which the configuration is stored, `my_go` in this
example, should match for convenience and clarity sake.

In subsequent steps, when running your connector locally, it's critical to ensure the port value matches the connection
string you provide in your `.env` file.

:::

#### What did this do?

This command created the following file structure in a `my_subgraph/connector/my_go` directory, with Go files in the
`functions` folder being your connector's entrypoint:

```bash
.
├── .ddnignore
├── .gitignore
├── .hasura-connector
│  ├── ...
├── compose.yaml
# highlight-start
├── functions
│  ├── hello.go
│  ├── types.generated.go
├── types
│  ├── connector.go
├── connector.generated.go
├── connector.go
├── main.go
├── go.mod
├── go.sum
├── Makefile
├── README.md
├── schema.generated.json
# highlight-end
```

### Step 2. Write business logic

The template code that ships with the Go connector provides some simple examples in the `functions/hello.go` file to
help explain how it works.

Functions that have a `Function` prefix are allowed to be exposed as a read-only queries. For example:

```go
// A hello argument
type HelloArguments struct {
  Greeting string `json:"greeting"` // value argument will be required
  Count    *int   `json:"count"`    // pointer arguments are optional
}

// A hello result
type HelloResult struct {
  Reply string `json:"reply"`
  Count int    `json:"count"`
}

// FunctionHello sends a hello message
func FunctionHello(ctx context.Context, state *types.State, arguments *HelloArguments) (*HelloResult, error) {
  count := 1
  if arguments.Count != nil {
    count = *arguments.Count + 1
  }
  return &HelloResult{
    Reply: fmt.Sprintf("Hi! %s", arguments.Greeting),
    Count: count,
  }, nil
}
```

Functions that have a `Procedure` prefix are allowed to be exposed as a mutation. For example:

```go
// A create author argument
type CreateAuthorArguments struct {
  Name string `json:"name"`
}

// A create author result
type CreateAuthorResult struct {
  ID   int    `json:"id"`
  Name string `json:"name"`
}

// ProcedureCreateAuthor creates an author
func ProcedureCreateAuthor(ctx context.Context, state *types.State, arguments *CreateAuthorArguments) (*CreateAuthorResult, error) {
  return &CreateAuthorResult{
    ID:   1,
    Name: arguments.Name,
  }, nil
}
```

The CLI plugin infers the third argument of the function and generates the input argument. The first result type is
generated as the response schema.

See more details in the documentation of
[hasura-ndc-go](https://github.com/hasura/ndc-sdk-go/tree/main/cmd/hasura-ndc-go) plugin.

### Step 3. Track the new function

Introspect the connector to generate connector schemas and the related Hasura metadata whenever there are new changes in
the `functions` folder.

```bash
ddn connector introspect my_go \
  --subgraph ./app/subgraph.yaml \
  --add-all-resources
```

### Step 4. Create a new API build and test

Next, let's create a new build of our supergraph:

```bash
ddn supergraph build local
```

:::tip Start your engines!

Want to test your supergraph? Don't forget to start your GraphQL engine using the following command:

```bash title="Run:"
HASURA_DDN_PAT=$(ddn auth print-pat) docker compose --env-file .env up --build --watch
```

This starts our Hasura Engine and observability tools. `HASURA_DDN_PAT=$(ddn auth print-pat)` gives the Hasura Engine
access to the DDN CLI's authentication token.

:::

You should see your command available, along with its documentation, in the GraphiQL explorer which you should be able
to access at
[`https://console.hasura.io/local/graphql?url=http://localhost:3000`](https://console.hasura.io/local/graphql?url=http://localhost:3000).

If you want a quick way of opening the console, you can run the following command:

```bash title="Run:"
ddn console -l
```

```graphql title=" You can then test your new command with the following query:"
query Hello {
  hello(greeting: "world") {
    reply
    count
  }
}
```


:::tip Privacy settings in some browsers

Your browser settings or privacy tools may prevent the Console from accessing your local Hasura instance. This could be
due to features designed to protect your privacy and security. Should you encounter one of these issues, we recommend
disabling these settings for the `console.hasura.io` domain.

[Chrome](https://www.google.com/chrome/) and [Firefox](https://www.mozilla.org/en-US/firefox/new/) are the recommended
browsers for the best experience with the Hasura Console including for local development.

:::

:::note Running Go in Docker

As you can see we're running Go and your functions directly on your own machine. You can also run your functions in a
Docker container along with your other Hasura services. The `connector init` command created a `Dockerfile` and a
`compose.yaml` file for you, so all you would need to do would be to:

- Make sure your port in your connector's `.env` and the one referenced in the
  `my_subgraph/connector/my_go/compose.yaml` file `ports:published` and `ports:target` fields match and don't conflict
  with any other services you may need to run.
- Add the Go connector compose file to the main compose file in the root of the project if you want them to start all
  together. Eg:

```yaml title="At the top of the root compose.yaml"
include:
  - path: my_subgraph/connector/my_go/compose.yaml
```

:::

## What did this do?

The commands above initialized a new Go connector, installed dependencies, and created a new function and procedure to
demonstrate how the connector works. We then added this function to our metadata as a command, and created a new build
of our supergraph.

## Next Steps

You can also [create relationships](/getting-started/build/07-create-a-relationship.mdx) between types in your
supergraph and your commands. This enables you to pair custom business logic with — for example — database tables, and
then transform or enrich data before sending it back to your consumers.

You can learn more about creating these and other relationships on the
[next page](/getting-started/build/07-create-a-relationship.mdx).
