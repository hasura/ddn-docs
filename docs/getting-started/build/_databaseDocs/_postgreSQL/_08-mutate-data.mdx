import Thumbnail from "@site/src/components/Thumbnail";

We provide two main ways to mutate PostgreSQL data: via auto-generated PostgreSQL mutations, and via the TypeScript connector.
The auto-generated mutations are more convenient, while the TypeScript connector is more flexible. Let's explore what
each option has to offer.

## Via auto-generated mutations

### What's about to happen?

The PostgreSQL connector provides auto-generated [point mutations](https://hasura.io/docs/3.0/connectors/postgresql/#point-mutations) -
these are insert, delete and update mutations affecting a single row using uniqueness constraints.
You can follow these steps to enable this feature, generate GraphQL mutations models, and define permissions for them.

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [supergraph](/getting-started/build/01-init-supergraph.mdx)
- A new or existing [subgraph](/getting-started/build/02-init-subgraph.mdx)
- A [PostgreSQL connector](/getting-started/build/03-connect-to-data/01-connect-a-source.mdx) initialized

:::

### Steps

#### Step 1. Enable auto-generated mutations

These auto-generated mutations feature is disabled by default by the PostgreSQL connector. In order to enable it,
open the ndc-postgres `configuration.json` found in the connector's directory, and edit the field `mutationsVersion`
to `"v2"`. This will tell the connector to generate mutations based on the configuration, for which we can create
models.

This can be done with the following sed script:

```bash title="Run the following command, updating the referenced paths to match your directory structure:"
sed -i 's/"mutationsVersion" = null/"mutationsVersion" = "v2"/' app/connector/my_pg/configuration.json
```

#### Step 2. Introspect the connector and add resources

Next, we will introspect the connector and import all of the newly available mutation commands.

```bash title="Run:"
ddn connector introspect my_pg --add-all-resources
```

This will create `.hml` files for each mutation model, such as:

```
.
├── app
│   ├── ...
│   ├── metadata
│   │   ├── ...
│   │   ├── V2DeleteUsersByEmail.hml
│   │   ├── V2InsertUsers.hml
│   │   ├── V2UpdateUsersById.hml
```

#### Step 3. Set command permissions via argument presets

Using [argument presets](/supergraph-modeling/permissions.mdx#boolean-expressions) we can specify a boolean expression
as a preset argument in place of the permission checks for each command.

Each command requires entries for the following arguments:

- Delete:
    - `preCheck` - check a condition on a row before deleting it.
- Insert:
    - `postCheck` - check a condition on the inserted row.
- Update:
    - `preCheck` - check a condition on a row before updating it.
    - `postCheck` - check a condition on the updated row.

We can specify these argument presets in the relevant `.hml` file for the required model.

For example, in the `V2DeleteUsersById` model, we can specify that the only row we allow to delete is one where `id`
is equals to `b1358c05-a457-41e7-b77e-56efce2cdd06` by adding the following `argumentPresets` structure to the
`CommandPermissions` in the `app/metadata/V2DeleteUsersById.hml` file.

```hml
kind: CommandPermissions
version: v1
definition:
  commandName: V2DeleteUsersById
  permissions:
    - role: admin
      allowExecution: true
      argumentPresets:
        - argument: preCheck
          value:
            booleanExpression:
              fieldComparison:
                field: id
                operator: _eq
                value:
                  literal: b1358c05-a457-41e7-b77e-56efce2cdd06
```

#### Step 4. Build and run

After editing the `.hml` files of your models, create a new build of our supergraph:

```bash title="Run:"
ddn supergraph build local
```

:::tip Start your engines!

Want to test your supergraph? Don't forget to start your GraphQL engine and connectors using the following command.

```bash title="Run:"
HASURA_DDN_PAT=$(ddn auth print-pat) docker compose --env-file .env up --build --watch
```

**If you haven't [included your connector(s)](/getting-started/build/01-init-supergraph.mdx) in your `compose.yaml`,
don't forget to start it as well.**

:::

Then, open your development console.

```bash title="Run:"
ddn console --local
```

Finally, you should see your command available, along with its documentation, in the GraphiQL explorer as a mutation.

## Via the TypeScript connector

### What's about to happen?

You can easily write data to your database using the native driver of your data source and the TypeScript connector. You
can follow the steps below to create a function which manipulates or inserts data and is exposed as a mutation via your
GraphQL API.

<Thumbnail src="/img/get-started/ERD/mutate-data.png" alt="Mutate data using your API" width="1000px" />

### Steps

#### Step 1. Install node packages

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [supergraph](/getting-started/build/01-init-supergraph.mdx)
- A new or existing [subgraph](/getting-started/build/02-init-subgraph.mdx)
- A [PostgreSQL connector](/getting-started/build/03-connect-to-data/01-connect-a-source.mdx) initialized
- A [DataConnectorLink](/getting-started/build/03-connect-to-data/02-create-source-metadata.mdx) configured
- A [TypeScript connector](/getting-started/build/06-add-business-logic.mdx) configured

:::

The TypeScript connector is a regular TypeScript project. We can use any Node.js packages we want.

We'll the `pg` package to access our connection string, saved as an environment variable, and to connect to our
database.

```bash title="From the my_subgraph/connector/my_ts directory, run:"
npm i pg
npm i --save-dev @types/pg
```

#### Step 2. Add the connection URI

If you've added a PostgreSQL connector, you'll have an environment variable available in your project's `.env` file.
However, we'll need to make it available to our TypeScript connector by doing the following:

#### Step 2.1 Update the TypeScript connector's `compose.yaml`

```yaml title="Add the reference to the connection URI used in your project's root .env:"
environment:
  HASURA_SERVICE_TOKEN_SECRET: $APP_MY_TS_HASURA_SERVICE_TOKEN_SECRET
  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: $APP_MY_TS_OTEL_EXPORTER_OTLP_TRACES_ENDPOINT
  OTEL_SERVICE_NAME: $APP_MY_TS_OTEL_SERVICE_NAME
  #highlight-start
  PG_CONNECTION_URI: $APP_MY_PG_CONNECTION_URI
  #highlight-end
```

#### Step 2.2 Update the TypeScript connector's `connector.yaml`

```bash title="Add the environment mapping:"
envMapping:
    HASURA_CONNECTOR_PORT:
      fromEnv: APP_MY_TS_HASURA_CONNECTOR_PORT
    HASURA_SERVICE_TOKEN_SECRET:
      fromEnv: APP_MY_TS_HASURA_SERVICE_TOKEN_SECRET
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT:
      fromEnv: APP_MY_TS_OTEL_EXPORTER_OTLP_TRACES_ENDPOINT
    OTEL_SERVICE_NAME:
      fromEnv: APP_MY_TS_OTEL_SERVICE_NAME
    #highlight-start
    PG_CONNECTION_URI:
      fromEnv: APP_MY_PG_CONNECTION_URI
    #highlight-end
```

#### Step 3. Create a function

The TypeScript connector uses [JSDoc comments](https://jsdoc.app/) to determine how to expose a function: either as a
query or a mutation. If we include the `@readOnly` tag, it will be exposed as a query. Simply omitting this tag will
expose the function as a mutation.

We can even add documentation that will be visible in the GraphiQL explorer by tagging `@param` for the argument(s) and
`@returns` for what will be returned by the mutation.

```ts title="my_subgraph/connectors/my_ts/functions.ts"
import { Client } from "pg";

/**
 * @param userData An object containing the user's data.
 * @returns The ID of the newly inserted user.
 */
export async function insertUser(userData: { name: string; email: string }): Promise<string> {
  const client = new Client({
    connectionString: process.env.PG_CONNECTION_URI,
  });

  await client.connect();

  const queryText = `
    INSERT INTO users (name, email)
    VALUES ($1, $2)
    RETURNING id
  `;
  const values = [userData.name, userData.email];
  const result = await client.query(queryText, values);

  await client.end();

  if (result.rows.length > 0) {
    return result.rows[0].id;
  } else {
    throw new Error("Failed to insert user");
  }
}
```

#### Step 4. Track the function

Just as before, we'll track our function using the CLI by first updating our `DataConnectorLink`.

```bash title="From any directory in the project, run:"
ddn connector-link update my_ts
```

And then bring in the new command.

```bash title="From any directory in the project, run:"
ddn command add my_ts insertUser
```

#### Step 5. Create a new build and test

Next, let's create a new build of our supergraph.

```bash title="Run:"
ddn supergraph build local
```

:::tip Start your engines!

Want to test your supergraph? Don't forget to start your GraphQL engine and connectors using the following command.

```bash title="Run:"
HASURA_DDN_PAT=$(ddn auth print-pat) docker compose --env-file .env up --build --watch
```

**If you haven't [included your connector(s)](/getting-started/build/01-init-supergraph.mdx) in your `compose.yaml`,
don't forget to start it as well.**

:::

Then, open your development console.

```bash title="Run:"
ddn console --local
```

Finally, you should see your command available, along with its documentation, in the GraphiQL explorer as a mutation.

### What did this do?

This function created a mutation that we can use to insert data directly into our database. We utilized raw SQL to
leverage the native features of PostgreSQL directly from our TypeScript function. While the example above is used to
insert data, you can use the same principles to modify or delete existing data in your database via your GraphQL API.
