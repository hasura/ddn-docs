import Thumbnail from "@site/src/components/Thumbnail";

## What's about to happen?

You can easily write data to your database using the native driver of your data source and the TypeScript connector. You
can follow the steps below to create a function which manipulates or inserts data and is exposed as a mutation via your
GraphQL API.

<Thumbnail src="/img/get-started/ERD/mutate-data.png" alt="Mutate data using your API" width="1000px" />

## Steps

### Step 1. Install node packages

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [supergraph](/getting-started/build/01-init-supergraph.mdx)
- A new or existing [subgraph](/getting-started/build/02-init-subgraph.mdx)
- A [ClickHouse connector](/getting-started/build/03-connect-to-data/01-connect-a-source.mdx) initialized
- A [DataConnectorLink](/getting-started/build/03-connect-to-data/02-create-source-metadata.mdx) configured
- A [TypeScript connector](/getting-started/build/06-add-business-logic.mdx) configured

:::

The TypeScript connector is a regular TypeScript project. We can use any Node.js packages we want.

We'll use the `dotenv` and
[`@clickhouse/client` packages](https://clickhouse.com/docs/en/integrations/language-clients/javascript) to access our
ClickHouse credentials and connection string, saved as environment variables, and to connect to our database.

```bash title="From the my_subgraph/connector/my_ts directory, run:"
npm i dotenv @clickhouse/client
```

### Step 2. Add the connection URI

We'll add our ClickHouse connection string and credentials as an environment variables to our connector's `.env.local`
file. This will allow us to access the connection string in our function.

```env title="my_subgraph/connectors/my_ts/.env.local"
CLICKHOUSE_URL=<your-clickhouse-connection-string>
CLICKHOUSE_USERNAME=<your-username>
CLICKHOUSE_PASSWORD=<your-passowrd>
```

### Step 3. Create a function

The TypeScript connector uses [JSDoc comments](https://jsdoc.app/) to determine how to expose a function: either as a
query or a mutation. If we include the `@readOnly` tag, it will be exposed as a query. Simply omitting this tag will
expose the function as a mutation.

We can even add documentation that will be visible in the GraphiQL explorer by tagging `@param` for the argument(s) and
`@returns` for what will be returned by the mutation.

```ts title="my_subgraph/connectors/my_ts/functions.ts"
import { ClickHouseClient, createClient } from "@clickhouse/client";
import dotenv from "dotenv";

dotenv.config();

/**
 * @param userData An object containing the user's data.
 * @returns The ID of the newly inserted user.
 */
export async function insertUser(userData: { name: string; email: string }): Promise<string> {
  const client: ClickHouseClient = createClient({
    url: process.env.CLICKHOUSE_URL,
    username: process.env.CLICKHOUSE_USER,
    password: process.env.CLICKHOUSE_PASSWORD,
  });

  await client.insert({
    table: "users",
    values: [{ name: userData.name, email: userData.email }],
    format: "JSONEachRow",
  });

  const selectQuery = `
    SELECT id
    FROM users
    WHERE name = {name: String} AND email = {email: String}
    ORDER BY id DESC
    LIMIT 1
  `;

  const result = await client.query({
    query: selectQuery,
    format: "JSON",
    query_params: {
      name: userData.name,
      email: userData.email,
    },
  });

  const data = await result.json();

  if (data.data.length > 0) {
    return data.data[0].id;
  } else {
    throw new Error("Failed to insert user");
  }
}
```

### Step 3. Track the function

Just as before, we'll track our function using the CLI by first updating our `DataConnectorLink`.

```bash title="From any directory in the project, run:"
ddn connector-link update my_ts \
  --env-file my_subgraph/.env.my_subgraph.local
```

And then bringing in the new command.

```bash title="From any directory in the project, run:"
ddn command add --connector-link my_ts --name insertUser
```

### Step 4. Create a new build and test

Next, let's create a new build of our supergraph.

```bash title="Run the following command, updating the referenced paths to match your directory structure:"
ddn supergraph build local \
  --output-dir engine \
  --subgraph-env-file my_subgraph:my_subgraph/.env.my_subgraph.local
```

:::tip Start your engines!

Want to test your supergraph? Don't forget to start your GraphQL engine and connectors using the following command.

```bash title="Run:"
HASURA_DDN_PAT=$(ddn auth print-pat) docker compose up --build --watch
```

**If you haven't [included your connector(s)](/getting-started/build/01-init-supergraph.mdx) in your `compose.yaml`,
don't forget to start it as well.**

:::

Finally, should see your command available, along with its documentation, in the GraphiQL explorer as a mutation.

## What did this do?

This function created a mutation that we can use to insert data directly into our database. We utilized raw SQL to
leverage the native features of ClickHouse directly from our TypeScript function. While the example above is used to
insert data, you can use the same principles to modify or delete existing data in your database via your GraphQL API.
