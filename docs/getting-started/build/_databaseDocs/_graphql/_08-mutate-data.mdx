import Thumbnail from "@site/src/components/Thumbnail";

## What's about to happen?

You can easily mutate data using your existing GraphQL mutations, which, if present when you introspected your schema,
will be available via your supergraph's API.

<Thumbnail src="/img/get-started/ERD/mutate-data.png" alt="Mutate data using your API" width="1000px" />

## Write your mutation

:::tip Required

- [The DDN CLI, VS Code extension, and Docker installed](/getting-started/build/00-prerequisites.mdx)
- A new or existing [supergraph](/getting-started/build/01-init-supergraph.mdx)
- A new or existing [subgraph](/getting-started/build/02-init-subgraph.mdx)
- A [GraphQL connector](/getting-started/build/03-connect-to-data/01-connect-a-source.mdx) initialized
- A [DataConnectorLink](/getting-started/build/03-connect-to-data/02-create-source-metadata.mdx) configured

:::

Simply head to the GraphiQL explorer in the console and write a valid mutation like the example below:

```graphql
mutation InsertTestingMutation {
  mySubgraph_insertTestingOne(object: { name: "Hasura" }) {
    id
    name
  }
}
```

This mutation is possible because, for each mutation present in your external source's schema, Hasura generates a
[Command](/supergraph-modeling/commands.mdx).

<details>
  <summary>You can see an example of a Command's metadata here.</summary>

```yaml
---
kind: ObjectType
version: v1
definition:
  name: TestingInsertInput
  description: input type for inserting data into table "testing"
  fields:
    - name: id
      type: Int
    - name: name
      type: String
  graphql:
    typeName: MySubgraph_TestingInsertInput
    inputTypeName: MySubgraph_TestingInsertInputInput
  dataConnectorTypeMapping:
    - dataConnectorName: my_graphql
      dataConnectorObjectType: testing_insert_input

---
kind: TypePermissions
version: v1
definition:
  typeName: TestingInsertInput
  permissions:
    - role: admin
      output:
        allowedFields:
          - id
          - name

---
kind: ObjectType
version: v1
definition:
  name: TestingOnConflict
  description: on_conflict condition type for table "testing"
  fields:
    - name: constraint
      type: TestingConstraint!
    - name: updateColumns
      type: "[TestingUpdateColumn!]!"
    - name: where
      type: TestingBoolExp
  graphql:
    typeName: MySubgraph_TestingOnConflict
    inputTypeName: MySubgraph_TestingOnConflictInput
  dataConnectorTypeMapping:
    - dataConnectorName: my_graphql
      dataConnectorObjectType: testing_on_conflict
      fieldMapping:
        constraint:
          column:
            name: constraint
        updateColumns:
          column:
            name: update_columns
        where:
          column:
            name: where

---
kind: TypePermissions
version: v1
definition:
  typeName: TestingOnConflict
  permissions:
    - role: admin
      output:
        allowedFields:
          - constraint
          - updateColumns
          - where

---
kind: Command
version: v1
definition:
  name: InsertTesting
  outputType: TestingMutationResponse
  arguments:
    - name: objects
      type: "[TestingInsertInput!]!"
      description: the rows to be inserted
    - name: onConflict
      type: TestingOnConflict
      description: upsert condition
  source:
    dataConnectorName: my_graphql
    dataConnectorCommand:
      procedure: insert_testing
    argumentMapping:
      objects: objects
      onConflict: on_conflict
  graphql:
    rootFieldName: mySubgraph_insertTesting
    rootFieldKind: Mutation
  description: 'insert data into the table: "testing"'

---
kind: CommandPermissions
version: v1
definition:
  commandName: InsertTesting
  permissions:
    - role: admin
      allowExecution: true
```

</details>
