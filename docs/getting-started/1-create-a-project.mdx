---
title: Create a project
sidebar_label: "Create a project"
sidebar_position: 2
description: "Learn how to create your first project, a supergraph, and see your APIs come to life with Hasura."
keywords:
  - hasura ddn
  - graphql api
  - quickstart
  - getting started
  - guide
  - supergraph
---

import Thumbnail from "@site/src/components/Thumbnail";

# Create a Project

## Introduction

To start, we'll walk you through the steps to:

- Create a new Hasura project
- Connect a database
- Execute your first query
- Create lightning-fast production builds all with the **new Hasura CLI**.

Throughout this guide, you'll be introduced to new Hasura concepts, like builds, our new metadata structure, and more.

:::tip What's about to happen?

We'll create a **project** on Hasura DDN, which is fully defined in metadata files using a simple directory structure.
We'll use the CLI's `create` command, which is a convenient way of setting up these files using best practices, to
scaffold out our project.

During this process, we'll add a [**data connector**](/docs/connectors/overview.mdx) to connect to a PostgreSQL data
source. Data connectors can connect to any data source. Connectors are available from Hasura and the community on the
[Connector Hub](https://hasura.io/connectors), or you can [write your own](/connectors/build-your-own-connector.mdx).

Once a project is defined, we can use the `dev` command to continually watch for changes and build the project to make
it available as an API on Hasura DDN.

:::

## Step 1: Prerequisites

1. **Install the [new Hasura CLI](/cli/installation.mdx)** ‚Äî¬†to quickly and easily create and manage your Hasura
   projects and builds.
2. **Install the [Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura)** ‚Äî
   with support for other editors coming soon!
3. Have a PostgreSQL database ‚Äî for supplying data to your API.

If you don't have a PostgreSQL database and prefer to connect to a cloud provider, check out our friends at
[Neon](https://neon.tech).

Additionally, we've provisioned a few read-only databases for you to use for this guide if you'd like. The connection
strings are available later in the third step.

:::info Powershell is recommended for Windows users

For users on Windows, we recommend utilizing
[Powershell](https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.4) for this tutorial. The
tutorial commands are based on Unix/Linux syntax. However, PowerShell on Windows supports these commands through
aliases, allowing you to use Unix/Linux-style commands directly on Windows.

:::

## Step 2: Login to Hasura

After our prerequisites are taken care of, login to Hasura Cloud with the CLI:

```bash
ddn login
```

This will open up a browser window and initiate an OAuth2 login flow. If the browser window doesn't open automatically,
use the link shown in the terminal output to launch the flow.

:::info New CLI?!

Yep! If you can't tell already, we've completely rewritten the CLI from the ground up. You can learn more about the new
commands by running:

```bash
ddn --help
```

:::

## Step 3: Create a new project

We'll use the `create project` command to create a new project:

```bash
ddn create project --dir ./my-first-supergraph
```

The CLI will respond with information about your new project, including the console URL:

```bash
+-------------+-----------------------------------------------------+
| Name        | <NAME>                                              |
+-------------+-----------------------------------------------------+
| ID          | <ID>                                                |
+-------------+-----------------------------------------------------+
| Console URL | https://console.hasura.io/project/<NAME>            |
+-------------+-----------------------------------------------------+
```

Additionally, it will log some information about the [project](/docs/ci-cd/projects.mdx) that was created locally.

### Step 3.1: Add a connector manifest

A [**connector manifest**](/ci-cd/projects.mdx) is the file which contains the details of the connector's configuration.
This tells Hasura DDN what capabilities of the connector has and how to build your connector for your data source.

Let's move into the project directory:

```bash
cd my-first-supergraph
```

Then, create a connector manifest by passing a name ‚Äî in this case `app_connector` ‚Äî to the `add connector-manifest`
command:

```bash
ddn add connector-manifest app_connector
```

The CLI will ask us if we want to add a `cloud` or `endpoints` connector. For now, we'll choose `cloud`:

```bash
? type (one of cloud | endpoints . This determines how the connector will be deployed. If unsure, choose 'cloud'):
#highlight-start
  ‚ñ∏ cloud
#highlight-end
    endpoints
```

The CLI will then ask us which type of connector we want to add. We'll choose `postgres`:

```bash
‚úî cloud
Use the arrow keys to navigate: ‚Üì ‚Üë ‚Üí ‚Üê
? hub-connector (name and version of connector in Hasura connector hub):
#highlight-start
  ‚ñ∏ hasura/postgres:<VERSION>
#highlight-end
```

The CLI will respond with information about our successfully-added connector and alert us to our next steps:

```bash
INF connector "hasura/postgres:<VERSION>" with name "app_connector" added successfully to Subgraph "app"
INF Please add your Postgres Connection URI as the value for APP_APP_CONNECTOR_CONNECTION_URI env var in base.env.yaml file
```

Next, we can open our project in VS Code and open the `base.env.yaml` file in the root of our project. We can add the
`APP_APP_CONNECTOR_CONNECTION_URI` environment variable referenced by the output of the CLI in our `base.env.yaml` file:

```yaml
supergraph: {}
subgraphs:
  app:
    APP_APP_CONNECTOR_CONNECTION_URI: postgresql://read_only_user:readonlyuser@35.236.11.122:5432/v3-docs-sample-app
```

:::info We're using the docs sample app's connection string

<details>

<summary>
  We also have another data set available in this dropdown or, if you wish, you can add your own connection string.
</summary>

A music-platform themed dataset.

```text
postgresql://read_only_user:readonlyuser@35.236.11.122:5432/Chinook
```

</details>

:::

### Step 3.2: Track tables as models

With our data connector configured, we'll need it to introspect our datasource to learn about the tables, their columns,
and those columns' types. The CLI can help us with this:

```bash
ddn update connector-manifest app_connector
```

The CLI will respond and let us know that the data connector was update successfully. Finally, with our data connector
configured to our datasource, we can track all of our tables as models, and build and then deploy our connector to
Hasura DDN:

```bash
ddn update connector-link app_connector --add-all-resources
```

:::info What are models?

[**Models**](/supergraph-modeling/models.mdx), defined in metadata, tell our GraphQL API how to expose collections from
our data sources.

:::

## Step 4: Build your GraphQL API

We can use `dev` mode to watch our project and create new builds as changes are made to our metadata:

```bash
ddn dev
```

We'll see the CLI creates our first build, displays the URL for our project's Console, and continues to watch for
changes üéâ

```bash
INF Preparing project...
INF Preparing connector "app_connector" in subgraph "app"
INF Updating ConnectorManifest for connector "app_connector" in subgraph "app"
INF Building connector "app_connector" in subgraph "app"
INF Waiting for deployment with ID "d2c96069-8dc6-452f-9b12-84896535492b" to go through...
‚óë+---------------+------------------------------------------------------------------------------+
| File Id       | e50204eb-1198-42c0-80fe-af049d79d4ae                                         |
+---------------+------------------------------------------------------------------------------+
| Deployment Id | d2c96069-8dc6-452f-9b12-84896535492b                                         |
+---------------+------------------------------------------------------------------------------+
| Build Url     | <URL>                                                                        |
+---------------+------------------------------------------------------------------------------+
INF Connectors built and running successfully
INF Updating ConnectorLink for connector "app_connector" in subgraph app
INF Updating URL...
INF env file base.env.yaml updated
INF Connector Link updated...
INF Doing a supergraph build...
‚óë+---------------+--------------------------------------------------------------------+
| Build ID      | 39aea467-07c4-4b13-8bbf-e475bb083267                               |
+---------------+--------------------------------------------------------------------+
| Build Version | cfe1ca9abf                                                         |
+---------------+--------------------------------------------------------------------+
| Build URL     | https://<PROJECT_NAME>-<ENV>-cfe1ca9abf.ddn.hasura.me/graphql      |
+---------------+--------------------------------------------------------------------+
| Project Id    | <PROJECT_ID>                                                       |
+---------------+--------------------------------------------------------------------+
# highlight-start
| Console Url   | https://console.hasura.com/project/<PROJECT_NAME>/graphql          |
# highlight-end
+---------------+--------------------------------------------------------------------+
| FQDN          | <PROJECT_NAME>.ddn.hasura.me                                       |
+---------------+--------------------------------------------------------------------+
| Environment   | dev                                                                |
+---------------+--------------------------------------------------------------------+
| Description   | Hasura Watch build at                                              |
|               | <TIMESTAMP>                                                        |
+---------------+--------------------------------------------------------------------+
```

:::info What's a build?

A [**build**](/ci-cd/builds.mdx) in Hasura DDN is an immutable state of your GraphQL API that represents a milestone in
your development cycle.

A project can have multiple builds for each [**environment**](/ci-cd/environments.mdx), and only one can be applied to
an environment's endpoint. All builds on a project have a unique URL on Hasura DDN to access their GraphQL API which can
be shared with other users.

Builds allow you and your team to quickly iterate and experiment with your project's metadata and allow for easier
rollbacks on production and greater collaboration during development.

:::

## Step 5: Run your first query

We're using the Docs Sample App schema for the visuals in this guide, but you can use the GraphiQL Explorer in Console
to create your own query or write it manually:

<Thumbnail src="/img/get-started/0.0.1_console-execute-query-on-build.png" alt="Execute a query" width="1000px" />

:::info Using our sample db? You can use this query!

```graphql
query UsersQuery {
  app_orders {
    id
    status
    delivery_date
  }
}
```

:::

:::tip Now would be a good time to git init

If you wish to use Git for version control and want to create a starting point to which you can rewind, run the
following at this point in a new tab of your terminal:

```bash
git init .
git add .
git commit -m "init supergraph"
```

:::

## Step 6: Track relationships

Using our extension ‚Äî fueled by [LSP](https://microsoft.github.io/language-server-protocol/), our underlying language
server ‚Äî let's track the different relationships in our source and have our API updated automatically.

In our browser, let's select the auto-select latest build option. This will ensure we're always seeing the latest build
generated by the `dev` command:

<Thumbnail src="/img/get-started/autoselectconsole.gif" alt="Execute a query" width="1000px" />

If we navigate to the `/app/app_connector/models/Orders.hml` file, we can track all the relationships present for a
complex, nested query to work. As you can see below, when we start typing `role`, LSP kicks in and assists us with
creating the following relationships which connects our models. We're triggering the auto-complete options using `TAB`
and `CTRL+SPACE`:

<!-- TODO: Add gif -->

The following are the required Relationship objects which you can copy and paste into this file:

```yaml
---
kind: Relationship
version: v1
definition:
  name: User
  source: Orders
  target:
    model:
      name: Users
      relationshipType: Object
  mapping:
    - source:
        fieldPath:
          - fieldName: user_id
      target:
        modelField:
          - fieldName: id

---
kind: Relationship
version: v1
definition:
  name: Product
  source: Orders
  target:
    model:
      name: Products
      relationshipType: Object
  mapping:
    - source:
        fieldPath:
          - fieldName: product_id
      target:
        modelField:
          - fieldName: id
```

If we head back to our browser, we should see the newest build that was generated by the CLI. We can then run the
following query to retrieve related information:

```graphql
query OrdersQuery {
  app_orders {
    id
    status
    delivery_date
    User {
      id
      name
      email
    }
    Product {
      id
      name
    }
  }
}
```

## Step 7: Add permissions

For our `users` model, we want to introduce an authorization concept we call
[**permissions**](/supergraph-modeling/permissions.mdx). This allows you to control which models are accessible to which
users ‚Äî via a **model permission** ‚Äî and which fields can be returned using **type permissions**.

Presently, if we run the following query, we'll see all users' information returned:

```graphql
query UsersQuery {
  app_users {
    id
    name
  }
}
```

In just a few lines ‚Äî and with the assistance of [LSP](https://microsoft.github.io/language-server-protocol/) powering
our [extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura) ‚Äî we can declaratively restrict
access so that a user is only able to see a limited set of their own data.

As you can see below, when we start typing `role`, LSP kicks in and assists us with creating the following permission
which checks the `x-hasura-user-id` header to only return a specific user's information. We're triggering the
auto-complete options using `TAB` and `CTRL+SPACE`:

<Thumbnail src="/img/get-started/modelPermissions.gif" alt="Execute a query" width="1000px" />

Find the `/app/app_connector/models/Users.hml` file. Then, with the guidance of LSP, let's make our `ModelPermissions`
object look like the metadata below in our `Users.hml` file:

```yaml
---
kind: ModelPermissions
version: v1
definition:
  modelName: Users
  permissions:
    - role: admin
      select:
        filter: null
    # highlight-start
    - role: user
      select:
        filter:
          fieldComparison:
            field: id
            operator: _eq
            value:
              sessionVariable: x-hasura-user-id
  # highlight-end
```

We can then modify the `TypePermissions` in the same file to the following:

```yaml
---
kind: TypePermissions
version: v1
definition:
  typeName: Users
  permissions:
    - role: admin
      output:
        allowedFields:
          - created_at
          - email
          - favorite_artist
          - id
          - is_email_verified
          - last_seen
          - name
          - password
          - updated_at
    # highlight-start
    - role: user
      output:
        allowedFields:
          - email
          - favorite_artist
          - id
          - name
          - password
    # highlight-end
```

Since the CLI should still be running in `dev` mode, as we make our changes it will create a new build automatically.
When our build is ready, we can add the following headers in our project's Console:

| Key                | Value                                  |
| ------------------ | -------------------------------------- |
| `x-hasura-role`    | `user`                                 |
| `x-hasura-user-id` | `7cf0a66c-65b7-11ed-b904-fb49f034fbbb` |

:::info Be careful of whitespace

If you copy/paste these values, take care to ensure no trailing whitespace.

:::

If we re-run the same query as before, Hasura will parse these values and apply our permissions, returning only Sean's
data and only the fields he access to under the `user` role:

<Thumbnail
  src="/img/get-started/0.0.1_console_query-with-permissions.png"
  alt="Execute a query with permissions"
  width="1000px"
/>

## What just happened?

### Project configuration

When you ran the `create project` command, the CLI created a new project for you on Hasura DDN. It also scaffolded out
all the necessary configuration and metadata in your project's directory:

```text
‚îú‚îÄ‚îÄ app
‚îú‚îÄ‚îÄ base.supergraph.hml
‚îú‚îÄ‚îÄ hasura.yaml
‚îî‚îÄ‚îÄ supergraph
```

You can learn more about project structure by visiting our [CI/CD section](/ci-cd/overview.mdx).

### Connector deployment

You created, configured, and deployed a PostgreSQL connector to Hasura DDN! Hasura can host these for you or you can
deploy them on your own infrastructure.

### Relationships

We instantly added all foreign-key [relationships](/supergraph-modeling/relationships.mdx) from our data source to our
API using LSP. This unlocks the potential for rich, deeply-nested queries that reach across different models in our API.

### Permissions

You also added a simple-to-use-but-powerful set of permissions to your `User` type, restricting users to only viewing
their own data and only what you want them to see. You can learn more about
[permissions here](/supergraph-modeling/permissions.mdx).
