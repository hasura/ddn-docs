---
sidebar_position: 3.5
sidebar_label: For Hasura v2 users
description: "Explore the transition from Hasura v2 to v3 for PostgreSQL users, including a roadmap for reintegrating
v2 features into Hasura v3 and DDN. Discover enhancements in PostgreSQL support, development tools, and future updates
for a smoother migration and increased productivity. Learn how Hasura's focus on scalability and performance continues
to evolve, ensuring a robust platform for both greenfield and brownfield projects."
keywords:
  - core concepts
  - hasura v2
  - hasura v3
  - postgresql
  - migration
  - roadmap
  - ddn
  - scalability
  - performance
  - development tools
---

# Hasura DDN for Hasura v2 Users

## Introduction

We've built Hasura DDN from the ground up for scale, both in terms of performance and the ease with which teams can
collaborate on any given API. As a Hasura v2 user, you may have encountered several pain points that Hasura DDN aims to
address.

Hasura DDN solves collaboration issues with other developers and teams. In v2, working in large teams was difficult,
especially with schema management, where merging changes often caused conflicts and inconsistencies. Keeping the
database schema in sync with application code was also challenging, leading to mismatches across development, staging,
and production environments.

Metadata handling and migrations were complex and error-prone, requiring substantial manual effort. Debugging and
monitoring were also problematic, involving manual log checks for queries, mutations, and subscriptions, and lacking
comprehensive performance monitoring tools. Implementing custom business logic through Actions or Remote Schemas
required additional infrastructure, which needed ongoing maintenance.

Deployment and scaling were not straightforward, with continuous deployment pipelines needing meticulous setup to ensure
proper deployment of metadata, migrations, and custom code. Horizontal scaling required significant configuration and
tuning.

By addressing these pain points, Hasura DDN ensures a smoother, more efficient development experience, better suited to
the demands of modern, large-scale applications and teams. Below, you'll learn about concepts with which you're familiar
and how they map to features in Hasura DDN.

## Hasura v2 concepts in Hasura DDN

### Instant GraphQL API

In Hasura v2, you added a connection string to your project and Hasura instantly generated a GraphQL API.

**In Hasura DDN, this is also true!** However, you're now given more flexibility and have the tools to rapidly iterate
and expand that API to include a dynamic range of sources, all organized into what we term **subgraphs** for clear team
ownership and rapid, risk-free development and deployment. You can learn more about
[the GraphQL API here](graphql-api/overview.mdx).

### The Hasura console

In Hasura v2, the console played a central role as the primary interface for managing your GraphQL API and its
associated metadata. The console provided a user-friendly graphical interface for various tasks, making it easier to
configure and interact with your Hasura instance without needing to write complex code or commands.

**In Hasura DDN, the console serves exclusively as an exploration and management tool**. It allows you to visualize,
explore, test, and deploy your API. The key difference here is that the console in Hasura DDN is not used to author or
edit your API. Learn how the console can be used to
[explore and manage your API here](getting-started/explore/index.mdx).

### The Hasura CLI

In Hasura v2, the CLI was used for various tasks such as managing metadata, applying migrations, and working with
environment configurations. It provided a command-line interface to automate and script these operations, making it
easier to integrate Hasura into CI/CD pipelines.

**In Hasura DDN, the CLI becomes your primary tool for constructing an API**. It is used for creating local projects,
scaffolding out metadata, and creating iterative, immutable builds of your API. Additionally, the CLI helps streamline
deployment processes and allows for easy automation, maintaining the functionality of managing and configuring your API
from the command line. Check out the [new command structure here](cli/overview.mdx) or
[learn how to create your first project here](getting-started/build/index.mdx).

### Connecting data sources

In Hasura v2, connecting data sources involved configuring your database and setting up the necessary permissions and
relationships within the console. This process was integral to enabling Hasura to generate a GraphQL API based on your
database schema.

**In Hasura DDN, connecting data sources is simplified and more flexible**. You can easily connect multiple types of
data sources, including relational databases, REST APIs, and other GraphQL services, all using a concept called
[**data connectors**](connectors/overview.mdx). This expanded capability allows for more diverse and comprehensive data
integration, facilitating a more unified API experience. The modular architecture of Hasura DDN ensures that changes in
one part of the API do not negatively impact others, allowing for greater autonomy and flexibility in development.

Further, you can easily configure all your relationships and permissions using a simple declarative syntax. Our
[Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura) makes this easier than
ever with scaffolding, auto-completion, and validation â€” ensuring your metadata is consistent and up-to-date before you
ship it to prod.

### Metadata and migrations

In Hasura v2, managing metadata and migrations required careful handling to ensure that changes were applied correctly
across different environments. This often involved manual steps and coordination among team members to avoid conflicts.

**In Hasura DDN, your project's metadata is decoupled from the data source**. The concept of migrations is completely
absent from Hasura DDN, and left entirely up to you and your team for how you wish to handle these changes. Your
metadata can easily be updated to match any changes to the database schema, ensuring there's no disruption to existing
services or users. You can learn more about the new metadata concepts in our
[supergraph modeling docs](supergraph-modeling/overview.mdx).

### Actions

In Hasura v2, Actions allowed you to integrate REST APIS or define custom business logic that could be executed as part
of your GraphQL API. This feature enabled bringing in existing REST APIS and extending the functionality of the API
beyond what was directly available through the database schema.

**In Hasura DDN, the [TypeScript connector](business-logic/typescript.mdx) takes the place of Actions**. You can define
more complex business logic â€” allowing enrichment and transformation of your data â€” and seamlessly integrate it with
other services via your existing API. This allows for creating richer and more dynamic APIs that can handle a wide range
of business requirements.

And, we'll host it all for you ðŸŽ‰

Finally, you can use the [OpenAPI connector](business-logic/open-api.mdx) â€” which leverages the TypeScript connector â€”
to immediately integrate any OpenAPI-compliant APIs.

### Remote Schemas

In Hasura v2, Remote Schemas allowed you to stitch together multiple GraphQL schemas into a single unified API. This was
particularly useful for integrating various microservices or third-party GraphQL APIs.

**In Hasura DDN, remote schemas are easier to manage and integrate using the
[GraphQL API data connector](https://github.com/hasura/ndc-graphql)**. This means external GraphQL APIs are treated like
any other data source and have the full assortment of permissions and relationships at your disposal.

### Monitoring

In Hasura v2, monitoring involved setting up external tools to track the performance and health of your GraphQL API.
This process could be complex and required additional configuration to ensure comprehensive monitoring.

**In Hasura DDN, monitoring capabilities are built-in and more robust**. You get better tools and dashboards for
tracking the performance, health, and usage of your API. This integrated approach makes it easier to keep an eye on your
API's performance and quickly identify and address any issues. Check out the
[observability docs](observability/overview.mdx) to learn about these improvements.

## Known limitations

By addressing these key areas, Hasura DDN ensures a smoother, more efficient development experience that is better
suited to the demands of modern, large-scale applications and teams. However, there are some current limitations of
which to be aware.

:::info Check out the roadmap

We are rapidly adding API features to Hasura DDN. To keep up to date, please check out our
[product roadmap](https://github.com/orgs/hasura/projects/201).

:::
