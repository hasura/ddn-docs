---
sidebar_position: 1
sidebar_label: JWT Mode
---

import Thumbnail from "@site/src/components/Thumbnail";

# JWT Mode

## Introduction

JWT mode requires that the client making the query sends a valid JSON Web Token to the Hasura Engine endpoint. This JWT
is provided by an auth service such as Auth0, AWS Cognito, Firebase, Clerk, or your own custom solution.

Hasura then verifies and decodes the JWT to extract `x-hasura-*` session variable claim values from a defined namespace
in the token.

The `x-hasura-default-role` and `x-hasura-allowed-roles` session variables are required, and you will also most likely
utilize the user id and any other information which you need to determine access to your data.

The token can be passed in the header of the request in a dedicated key, or using the `Authorization` header with the
`Bearer` prefix, or as a cookie. All these options are defined in the `AuthConfig` object in your metadata.

<Thumbnail src="/img/auth/auth-jwt-overview-diagram.png" alt="Authentication using JWT" />

# Enabling JWT Authentication

## Introduction

You can enable your Hasura DDN instance to use JWTs in just a few steps.

## Step 1. Update your AuthConfig

Hasura utilizes an [AuthConfig](/supergraph-modeling/auth-config.mdx) object that allows you to define the configuration
for your authentication service. In a standard setup the `auth-config.hml` file can be found in your `globals`
directory.

:::tip Hasura DDN VS Code extension

You can use [Hasura's VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura) to
scaffold out your `AuthConfig` object by typing `AuthConfig` and selecting this object from the list of available
options. As you navigate through the skeleton, you can type `CTRL+SPACEBAR` at any point to reveal options for the
different key-value pairs.

:::

Below, we're showing using the `BearerAuthorization` header location format using a fixed secret key from an environment
variable. However, Hasura DDN supports other methods for
[where the engine can locate the JWT](supergraph-modeling/auth-config.mdx#authconfig-jwttokenlocation) and
[how it is verified](supergraph-modeling/auth-config.mdx#authconfig-jwtalgorithm).

```yaml title="globals/metadata/auth-config.hml"
kind: AuthConfig
version: v2
definition:
  mode:
    jwt:
      claimsConfig:
        namespace:
          claimsFormat: Json
          location: /claims.jwt.hasura.io
      tokenLocation:
        type: BearerAuthorization
      key:
        fixed:
          algorithm: HS256
          key:
            valueFromEnv: AUTH_SECRET
```

Read more about other setup options [here](/supergraph-modeling/auth-config.mdx#authconfig-jwtconfig).

## Step 2. Define the JWT with custom claims

Your auth service should include an object with a key of `claims.jwt.hasura.io` in the JWT. Within this, each claim
should be prefixed with `x-hasura-*` and include the relevant information. Note that an extra optional `x-hasura-role`
**header** can be passed to override the default role found in the JWT's custom claims.

| Key                      | Required | Value                                                                                                          |
| ------------------------ | -------- | -------------------------------------------------------------------------------------------------------------- |
| `x-hasura-default-role`  | Yes      | The role that will be used when the optional x-hasura-role header is not passed                                |
| `x-hasura-allowed-roles` | Yes      | A list of allowed roles for the user making the request.                                                       |
| `x-hasura-[custom]`      | No       | Where `[custom]` is any string you wish (e.g., `org`, `user-id`, `customer`). The value can be any JSON value. |

In the simple example below, we're including the required claims by stating the default role is `admin` and the list of
available roles is limited to `user` and `admin`. Additionally, we're passing a custom key of `x-hasura-user-id` which
can be used with [permissions](/supergraph-modeling/permissions.mdx) when executing queries.
[Read more about the default claims here](/auth/jwt/jwt-configuration.mdx#hasura-jwt-format).

```json
{
  "iat": 1735916718,
  "exp": 1796916677,
  "claims.jwt.hasura.io": {
    "x-hasura-default-role": "admin",
    "x-hasura-allowed-roles": ["user", "admin"],
    "x-hasura-user-id": 1234
  }
}
```

Your auth service will encode this object using a secret and create a token which can then be passed to Hasura. You can
see an example of the above token encoded
[here](https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3MzU5MTY3MTgsImV4cCI6MTc5NjkxNjY3NywiY2xhaW1zLmp3dC5oYXN1cmEuaW8iOnsieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS1hbGxvd2VkLXJvbGVzIjpbInVzZXIiLCJhZG1pbiJdLCJ4LWhhc3VyYS11c2VyLWlkIjoxMjM0fX0.1Dv6B077loe9wGcUFwK_JAHRUtLOZHOEp9EE-OehUzY).
The signature secret to verify this token with the HS256 algorithm is `ultra-secret-very-secret-super-secret-key`.

:::warning Setting audience check

Certain JWT providers (like Firebase) share JWKs between multiple tenants. They use the `aud` claim of JWT to specify
the intended tenant for the JWT. Setting the `audience` field in the Hasura JWT configuration will make sure that the
`aud` claim from the JWT is also checked during verification. Not doing this check will allow JWTs issued for other
tenants to be valid as well.

In these cases, you **MUST** set the `audience` field to appropriate value. **Failing to do so is a major security
vulnerability**. Learn how to set this [here](supergraph-modeling/auth-config.mdx#authconfig-jwtconfig).

:::

## Step 3. Add permissions to an object in your supergraph

{/* TODO: Add permissions to an object in your supergraph */}

## Step 3. Rebuild your supergraph

Once you've updated your `AuthConfig` object in `auth-config.hml` and updated your claims, you can rebuild your
supergraph and test it locally.

```bash title="For example, from the root of your project, run:"
ddn supergraph build local
```

## Step 4. Make an authenticated request

In the example above, we're using the `BearerAuthorization` method. As such, as we can make a request to our Hasura DDN
instance by including a header with the key-value of `Authorization: Bearer <our-encoded-token>`. For testing, you can
pass this value in the Hasura DDN console's header section.

{/* TODO: Make an authenticated request example */}

## Next steps

If you're looking for step-by-step help to get started with common authentication providers, check
[this section](/auth/jwt/tutorials/index.mdx) of tutorials.

{/* TODO: Rewrite this section */} **Authentication is only part of the puzzle!** Hasura DDN empowers you to easily
write your access-control rules, commonly known as authorization, using declarative metadata. You can use the values
passed in your JWTs to then limit which [models](/supergraph-modeling/permissions.mdx#modelpermissions-modelpermissions)
and [types](/supergraph-modeling/permissions.mdx#typepermissions-typepermissions) a user has access to with each
request.
