---
sidebar_position: 2
sidebar_label: Namespaces
description: Hasura collaboration namespaces
keywords:
  - hasura
  - graphql
  - collaboration
  - teams
  - namespaces
---

# Metadata Namespaces

For a multi-team organization working on a V3 project, it makes sense for a team to not have access to all the metadata
objects. Namespaces introduces the notion of module system for metadata:

1. A project can have a collection of namespaces and the project's metadata is the 'union' of metadata objects across all
   namespaces of the project.
2. Each namespace can be updated independently.

This patch operation on metadata is governed by the following rules:
1. Teams can only update namespaces that they have access to.
2. A namespace is the owner of all its metadata objects and no other namespace can "modify" an entity owned by a
   namespace. For example,
   1. If a `shipping` namespace defines a model `TrackShipment`, no other namespace can add relationships on the model
      or permissions for a role on the model.
   2. If a `shipping` namespace adds a data source `shipping-crm`, no other namespace can define models on the
      `shipping-crm` data source.

A metadata with namespaces looks something like the following:

```json
[
  {
    "namespace": "foo",
    "metadata": [
      {<metadata obj>},
      {<metadata obj>}
    ]
  },
  {<metadata with namespace},
  ...
]
```

The metadata objects in a namespaces must follow the ownership rules for the metadata objects:

1. `DataSource`/ `PostgresDataSource` : The namespace that defines a data source owns it. This means that no other
   namespace can reference this data source in their `ModelSources`, `ScalarTypeRepresentation`, etc.
2. `ObjectType`: An object type can only be used by the namespace that defines it.
3. `ScalarTypeRepresentation`: The data source in a `ScalarTypeRepresentation` should be owned by the same namespace
   that is owing the metadata object.
4. `NewType`: The wrapped custom type in the new type must be from the same namespace.
5. `Model`: A `Model` can reference types that belongs to the namespace that defines the `Model`. 
6. `ModelSource`: A `ModelSource` can reference types, models and data sources defined in the same namespace. 
7. `Relationship`: The source type used in the `Relationship` should be owned by the namespace defining the
   `Relationship`. Please note that the the target type can be from any namespace.
8. `TypeOutputPermissions`: The namespace defining the `TypeOutputPermissions` should own the type on which the
   permission is being defined.
9. `ModelSelectPermissions`: Similar to `TypeOutputPermissions`, the namespace should own the model.
10. `GraphQLTypeDefinition`: Similar to `ModelSelectPermissions`, the namespace should own the graphql type.
11. `ModelGraphQLAPI`: The namespace defining the `ModelGraphQLAPI` should also own the `Model` used for the graphql
    API.
12. `ScalarTypeGraphQLRepresentation`: The data source used in the `ScalarTypeGraphQLRepresentation` should be owned by
    the same namespace that defines the `ScalarTypeGraphQLRepresentation`.
13. `AuthConfg`: Any namespace can define this.
