---
sidebar_position: 11
sidebar_label: Permissions
description:
  "This page provides an understanding of how to define permissions, control access or set authorization rules on output
  types, models, and commands in your supergraph. It essentially makes management of roles and accessibility simple and
  efficient."
toc_max_heading_level: 4
keywords:
  - hasura
  - hasura permissions guide
  - api authorization
  - define permissions
  - model permissions
  - command permissions
  - data domains
  - api control rules
  - access management
seoFrontMatterUpdated: true
---

import Thumbnail from "@site/src/components/Thumbnail";

# Permissions

## Introduction

Access control rules are essential for securing your data and ensuring that only authorized users can access it. In
Hasura, these are referred to as **permissions**. You can use permissions to control access to certain rows or columns
in your database, or to restrict access to certain operations or fields in your GraphQL API.

The following types of permissions can be defined:

| Type               | Description                                                                       |
| ------------------ | --------------------------------------------------------------------------------- |
| TypePermissions    | Define which fields are allowed to be accessed by a role on an output type.       |
| ModelPermissions   | Define which objects or rows within a model are allowed to be accessed by a role. |
| CommandPermissions | Define whether the command is executable by a role.                               |

:::info VS Code extension assisted authoring

Permissions are written in your various HML files. If you're using a compatible editor (such as VS Code with the
[Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura)), assisted authoring
will help you write permissions more efficiently. It will provide you with auto-completion, syntax highlighting, and
error checking as you write your permissions.

:::

## Argument presets

Argument presets can be used to enforce row-level security. They can be defined on arguments for `Types`, `Models` and
`Commands`.

## Argument presets

### Literals

For example, given a `Command` called `get_article_by_id`, with a single argument called `id`, you can prepopulate that
argument for the `user` role.

```yaml
kind: CommandPermissions
version: v1
definition:
  commandName: get_article_by_id
  permissions:
    - role: admin
      allowExecution: true
    - role: user
      allowExecution: true
      argumentPresets:
        - argument: id
          value:
            literal: 100
```

This means that `admin` users are able to provide whatever `id` they like to `get_article_by_id`, but the argument is
not available in the GraphQL schema for the `user` role, and instead they always receive the same article every time.

### Session variables

What might be a little more helpful is a a `Command` called `get_articles_by_author_id`, with a single argument called
`author_id`. Here you can make it so that a `user` can only fetch articles with an `author_id` that matches their
`x-hasura-user-id` header.

```yaml
kind: CommandPermissions
version: v1
definition:
  commandName: get_articles_by_author_id
  permissions:
    - role: admin
      allowExecution: true
    - role: user
      allowExecution: true
      argumentPresets:
        - argument: id
          value:
            sessionVariable: x-hasura-user-id
```

This means `admin` users, once again, are able to provide their own `author_id`, but a `user` can only see the articles
they have written.

### Boolean expressions

We can also use argument presets to pass actual logical expressions to our data sources to control how they do things.

For example, a data connector might expose a `Command` called `delete_user_by_id` with two arguments - `user_id` and
`pre_check`. `user_id` is the primary key of the user you'd like to remove, and `pre_check` lets you provide a custom
boolean expression.

```yaml
kind: CommandPermissions
version: v1
definition:
  commandName: delete_user_by_id
  permissions:
    - role: admin
      allowExecution: true
    - role: user
      allowExecution: true
      argumentPresets:
        - argument: pre_check
          value:
            booleanExpression:
              fieldComparison:
                field: is_invincible
                operator: _eq
                value:
                  literal: false
```

Now, when `admin` runs this command, once again, they can do what they want, and provide their own `pre_check` if they
want. The `user` however, is able to pass a `user_id` argument, but the `pre_check` expression is passed to the data
connector which will only let them delete the row if the row's `is_invincible` value is set to `false`.

## Metadata structure

