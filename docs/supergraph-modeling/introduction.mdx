---
sidebar_position: 2
sidebar_label: Introduction
description:
  "Explore the enhanced capabilities of supergraph modeling. Understand how it provides an efficient tool for metadata
  generation, data source management, and lays the foundation for building API data domains. Learn the mechanism of data
  connectors and the corresponding specifications, models, commands, relationships, and permissions."
keywords:
  - hasura ddn
  - data connectivity
  - data management
  - api development
  - metadata generation
  - data connectors
  - graphql api
  - data modeling
  - api permissions
seoFrontMatterUpdated: true
---

# Introduction

Hasura v3 introduces the concept of the data supergraph.

Your Hasura metadata describes your supergraph and its subgraphs. This metadata is used to build your supergraph, the
connectors that link your data sources to models and commands in your API, and the various relationships and permissions
that link together types from data sources and restrict access control using permissions within each subgraph.

## How is this different from Hasura v2 metadata?

Hasura v2 metadata was specifically designed for GraphQL and included database-level modeling constructs such as
Postgres tables, whereas Hasura v3 utilizes a general specification that is not coupled to GraphQL and introduces new
abstract constructs such as **models** and **commands** that are common across different data sources.

Functionally, the v2 metadata relied directly on the raw data source for information like columns and fields, whereas
supergraph metadata is independent of the data source. All fields and types are explicitly defined within the metadata
itself which eliminates the necessity for data source schema introspection at startup to generate a GraphQL schema.
Also, the v3 metadata is still semantically consistent even if the underlying data source has changed.

Compared to the v2 metadata, there is a lot more flexibility offered when configuring your GraphQL API.

**In this way, your data supergraph is decoupled from any underlying database, data source, or other physical layer of
storage.** This is powerful as it enables you to consistently deliver data with the same structure and authorization
rules. This consistency remains intact even when you make significant changes, such as transitioning from MySQL to
PostgreSQL, adopting MongoDB for read operations and MySQL for write operations, altering your transactional email
system, or switching payment providers.

## Learn more

Using the pages within this directory, you'll find explanations of the different metadata objects and examples
illustrating how to use them.
