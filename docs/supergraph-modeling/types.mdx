---
sidebar_position: 5
sidebar_label: Types
description:
  "Explore types in Hasura, discover primitive types, custom types and container types. Learn how to define your data
  structure and map existing data connector scalars to types in your data domain. Understand how these elements form the
  foundation of your data, allowing for flexibility and seamless interconnection."
keywords:
  - hasura documentation
  - graphql data structure
  - data domain mapping
  - hasura ddn
  - hasura data specification
  - graphql schema
  - data connector scalars
  - primitive types
  - custom types
toc_max_heading_level: 4
seoFrontMatterUpdated: true
---

# Types

## Introduction

Types serve as the fundamental elements that define the structure of your data.

Being able to define types in your data domain is beneficial because it provides you with the flexibility to define them
separately from the types referenced by a data connector's source.

The specification employs a concrete type system that includes both primitive and user-defined types. All subsequent
layers, such as models, commands, and relationships are defined in terms of these types.

The types can be one of the following:

| Type            | Description                                                                                              |
| --------------- | -------------------------------------------------------------------------------------------------------- |
| Primitive       | These are the basic types `ID`, `Int`, `Float`, `Boolean`, or `String`.                                  |
| Custom          | These are user-defined types, such as ScalarType or ObjectType.                                          |
| Type References | When specifying the types of a field or an argument, you can mark them as required `!` or repeated `[]`. |

The spec also allows you to map existing data connector scalars to types in your data domain.

You can also define custom types by either aliasing existing types (such as primitives or custom), or you can define a
type with fields. In turn, the fields themselves can be a primitive or another custom type.

Type references are types of fields and arguments that refer to other primitive or custom types and which can be marked
as nullable, required or repeated (in the case of arrays).

[//]: # "TODO: Add reference to scalars ðŸ‘‡ when data connector are documented"

Scalar type representation helps in mapping data connector scalars to any of the above types.

## Primitive types and type references {#primitive-types-and-type-references}

Primitive types supported are `ID`, `Int`, `Float`, `Boolean` and `String`.

Type references follow [GraphQL type syntax](https://spec.graphql.org/June2018/#sec-Combining-List-and-Non-Null). Fields
and arguments are nullable by default. To represent non-nullability, specify a `!` after the type name. Similarly, array
fields and arguments are wrapped in `[]`.

### Examples

If the field is nullable, it should be defined as

```yaml
name: category
type: ProductCategory
```

If the field is non-nullable, it should be defined as

```yaml
name: category
type: ProductCategory!
```

If the field is a nullable array of nullable type, it should be defined as

```yaml
name: tags
type: [String]
```

If the field is a nullable array of non-nullable type, it should be defined as

```yaml
name: tags
type: [String!]
```

If the field is a non-nullable array of nullable type, it should be defined as

```yaml
name: tags
type:
  [String]!
```

If the field is a non-nullable array of non-nullable type, it should be defined as

```yaml
name: tags
type:
  [String!]!
```

## Metadata structure

