---
sidebar_position: 10
sidebar_label: Relationships
description:
  "Expand your understanding of relationships in Hasura, learn how to define linked or nested data queries, create
  relationships between types and models. Explore mapping relationships with in-depth annotated examples and explore
  connecting data across namespaces."
keywords:
  - hasura relationships
  - data mapping
  - graphql queries
  - linked data queries
  - nested data queries
  - hasura data modeling
  - data connectivity
  - hasura data sources
  - hasura api configuration
toc_max_heading_level: 4
seoFrontMatterUpdated: true
---

import GraphiQLIDE from "@site/src/components/GraphiQLIDE";

# Relationships

## Introduction

Defining a relationship allows you to make queries across linked information.

Relationships are defined in metadata **from an [object type](./types.mdx#objecttype-objecttype), to a
[model](./models.mdx) or [command](./commands.mdx)**.

This enables you to create complex queries, where you can fetch related data in a single query.

By defining a `Relationship` object, **all [models](./models.mdx) or [commands](./commands.mdx) whose output type is the
source object type defined in the relationship will now have a connection to the target model or command.**

```yaml
kind: Relationship
version: v1
definition:
  name: customer
  sourceType: orders
  target:
    model:
      name: customers
      subgraph: customers
      relationshipType: Object
  mapping:
    - source:
        fieldPath:
          - fieldName: customerId
      target:
        modelField:
          - fieldName: customerId
  description: The customer details for an order
```

So from this relationship definition, all models or commands in the supergraph whose output type is the `orders` object
type will now have a connection to the `customers` model via the `customer` relationship field on the `orders` type.

So, as in example 1 below, you can now fetch the customer when you query orders. Note that also, if you had, for
instance an arbitrary command such as `getCustomerLastOrder` which also returned an order from a customer id, you can
now also return the customer's details for that returned order in the same single query from this relationship.

### Example 1 - Object Type to a Model.

As mentioned above, in an e-commerce context, you will likely have customers and orders, and you want to relate them so
that when you query orders you can easily fetch the customer on that order.

To do this in DDN metadata for this example, you might have an `orders` **model** which returns an `orders` **object
type** and you want to relate that to a `customers` **model** and whatever object type it returns.

**Example:** Fetch a list of orders along with the customer details for each order:

<GraphiQLIDE
  query={`query OrdersAndCustomers {
  orders {
    orderId
    orderDate
    customer {
      customerId
      name
      email
    }
  }
}`}
  response={`{
  "data": {
    "orders": [
      {
        "orderId": "ORD001",
        "orderDate": "2024-05-10",
        "customer": {
          "customerId": "CUST001",
          "name": "John Doe",
          "email": "john.doe@example.com"
        }
      },
      {
        "orderId": "ORD002",
        "orderDate": "2024-05-11",
        "customer": {
          "customerId": "CUST002",
          "name": "Jane Smith",
          "email": "jane.smith@example.com"
        }
      }
    ]
  }
}`}
/>

Here is the corresponding relationship configuration which enables this query:

```yaml
kind: Relationship
version: v1
definition:
  name: customer
  sourceType: orders
  target:
    model:
      name: customers
      subgraph: customers
      relationshipType: Object
  mapping:
    - source:
        fieldPath:
          - fieldName: customerId
      target:
        modelField:
          - fieldName: customerId
  description: The customer details for an order
```

Now, you can also retrieve the customer details for any model or command in your schema that returns the `orders` object
type.

For convenience, this relationship configuration would best be located with your `orders` object type and model.

### Example 2 - Object Type to a Command

Let's say you have a `user` object type in your graph, and also a command which responds with the current logged-in user
information (say `getLoggedInUserInfo`). Now you can link these two, by defining a relationship from the `user` object
type to `getLoggedInUserInfo`.

Let's say we name the relationship `currentSession`. Now you can make a single query from your client to get a user's
data and their current session information.

**Example:** fetch a list of users and the current session information of each user:

<GraphiQLIDE
  query={`query UsersAndCurrentSession {
  users {
    id
    username
    currentSession {
      activeSince
    }
  }
}`}
  response={`{
  "data": {
    "users": [
      {
        "id": 1,
        "username": "sit_amet",
        "currentSession": {
          "activeSince": "2024-04-01T07:08:22+0000"
        }
      },
      {
        "id": 2,
        "username": "fancy_nibh",
        "currentSession": {
          "activeSince": "2024-04-01T07:08:22+0000"
        }
      },
      {
        "id": 3,
        "username": "just_joe",
        "currentSession": {
          "activeSince": "2024-04-01T07:08:22+0000"
        }
      }
    ]
  }
}`}
/>

Here is the corresponding relationship configuration which enables this query:

```yaml
kind: Relationship
version: v1
definition:
  name: currentSession
  sourceType: user
  target:
    command:
      name: getLoggedInUserInfo
      subgraph: users
  mapping:
    - source:
        fieldPath:
          - fieldName: id
      target:
        argument:
          argumentName: user_id
  description: The current session information for the user
```

### Example 3 - Related Commands

Hasura DDN also allows you to link commands together from a source type to query related data.

**Example:** fetch the result of one command and use it as input for another command:

<GraphiQLIDE
  query={`query TrackOrder {
    trackOrder(orderId: "ORD12345") {
      trackingNumber
      shippingDetails {
        carrier
        estimatedDeliveryDate
        currentStatus
      }
    }
  }
`}
  response={`{
  "data": {
    "trackOrder": {
      "trackingNumber": "1Z9999999999999999",
      "shippingDetails": {
        "carrier": "UPS",
        "estimatedDeliveryDate": "2024-05-25",
        "currentStatus": "In Transit"
      }
    }
  }
}
`}
/>

And the corresponding relationship configuration which enables this query:

```yaml
kind: Relationship
version: v1
definition:
  name: shippingDetails
  sourceType: trackOrder
  target:
    command:
      name: getShippingDetails
      subgraph: orders
  mapping:
    - source:
        fieldPath:
          - fieldName: trackingNumber
      target:
        argument:
          argumentName: trackingNumber
  description: The shipping details for an order based on its tracking number
```

:::info VS Code extension assisted authoring

Relationships are written in your various HML files. If you're using a compatible editor (such as VS Code with the
[Hasura VS Code extension](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura)), assisted authoring
will help you create relationships more efficiently. It will provide you with auto-completion, syntax highlighting, and
error checking as you write your relationships.

The CLI also works to automatically track your relationships for you whenever you add or update a data connector.

:::

## Metadata structure

