---
sidebar_position: 7
sidebar_label: Relationships
description:
  "Expand your understanding of relationships in Hasura, learn how to define linked or nested data queries, create
  relationships between types and models. Explore mapping relationships with in-depth annotated examples and explore
  connecting data across namespaces."
keywords:
  - hasura relationships
  - data mapping
  - graphql queries
  - linked data queries
  - nested data queries
  - hasura data modeling
  - data connectivity
  - hasura data sources
  - hasura api configuration
toc_max_heading_level: 4
seoFrontMatterUpdated: true
---

# Relationships

## Introduction

A relationship allows you to query nested or linked information, for example from `Manufacturers` to `Products`. A
relationship allows you extend [type](./types.mdx) objects with related [models](./models.mdx).

To create a relationship, you will need to define an object with `kind: Relationship` and `version: v1`. The object
`definition` has a `name`, the `source` type, a `target` model and the `mapping` between the two.

### Metadata structure

```yaml
kind: Relationship
version: v1
definition:
  source: <String>
  name: <String>
  target: <TargetConfiguration>
  mapping: <RelationshipMapping>
```

| Field     | Type                                            | Required | Description                                                                                      |
| --------- | ----------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------ |
| `source`  | `String`                                        | true     | The source [type](./types.mdx) of the relationship.                                              |
| `name`    | `String`                                        | true     | The name of the relationship.                                                                    |
| `target`  | [`TargetConfiguration`](#targetconfiguration)   | true     | The target of the relationship.                                                                  |
| `mapping` | [`[RelationshipMapping]`](#relationshipmapping) | true     | Defines how the `Source` and `Target` should be connected. This field expects a list of objects. |

#### TargetConfiguration

```yaml
target:
  model: <TargetModel>
```

| Field   | Type                          | Required | Description                                            |
| ------- | ----------------------------- | -------- | ------------------------------------------------------ |
| `model` | [`TargetModel`](#targetmodel) | true     | The target [model](./models.mdx) for the relationship. |

#### TargetModel

```yaml
model:
  name: <String>
  subgraph: <String>
  relationshipType: <RelationshipType>
```

| Field              | Type                                    | Required | Description                                                                                     |
| ------------------ | --------------------------------------- | -------- | ----------------------------------------------------------------------------------------------- |
| `name`             | `String`                                | true     | The name of the target model.                                                                   |
| `subgraph`         | `String`                                | false    | The subgraph of the target model. Defaults to the subgraph of the relationship metadata object. |
| `relationshipType` | [`RelationshipType`](#relationshiptype) | true     | The type of the relationship: either `Object` or `Array`.                                       |

#### RelationshipType

```yaml
relationshipType: Object | Array
```

| Value    | Description                                     |
| -------- | ----------------------------------------------- |
| `Object` | The relationship is a one-to-one relationship.  |
| `Array`  | The relationship is a one-to-many relationship. |

#### RelationshipMapping

Defines how the source type maps to the target model in this relationship. The mapping can have multiple links.

```yaml
mapping:
  - source: <RelationshipMappingSource>
    target: <RelationshipMappingTarget>
```

| Field    | Type                                                      | Required | Description                      |
| -------- | --------------------------------------------------------- | -------- | -------------------------------- |
| `source` | [`RelationshipMappingSource`](#relationshipmappingsource) | true     | The source link of this mapping. |
| `target` | [`RelationshipMappingTarget`](#relationshipmappingtarget) | true     | The target link of this mapping. |

#### RelationshipMappingSource

```yaml
source:
  fieldPath:
    - <FieldAccess>
```

| Field       | Type                            | Required | Description                        |
| ----------- | ------------------------------- | -------- | ---------------------------------- |
| `fieldPath` | [`[FieldAccess]`](#fieldaccess) | true     | The field path of the source link. |

#### RelationshipMappingTarget

```yaml
target:
  modelField:
    - <FieldAccess>
```

| Field        | Type                            | Required | Description                                                 |
| ------------ | ------------------------------- | -------- | ----------------------------------------------------------- |
| `modelField` | [`[FieldAccess]`](#fieldaccess) | true     | The field path of the target model the source link maps to. |

#### FieldAccess

Defines a single element of a field path.

```yaml
fieldName: <FieldName>
```

| Field       | Type     | Required | Description                                  |
| ----------- | -------- | -------- | -------------------------------------------- |
| `fieldName` | `String` | true     | The name of the field for this path element. |

## Example

### Basic relationship

Let's add the following relationships to the above types.

1. `Array` relationship where `author` has many `Articles`:

```yaml
kind: Relationship
version:
definition:
  source: author
  name: articles
  target:
    model:
      name: Articles
      relationshipType: Array
  mappings:
    - source:
        fieldPath:
          - fieldName: id
      target:
        modelField:
          - fieldName: author_id
```

2. `Object` relationship where `article` has one `Author`:

```yaml
kind: Relationship
version: v1
definition:
  source: article
  name: author
  target:
    model:
      name: Authors
      relationshipType: Object
  mappings:
    - source:
        fieldPath:
          - fieldName: author_id
      target:
        modelField:
          - fieldName: id
```

The resulting GraphQL schema will appear as:

```graphql
type Authors {
  author_id: Int!
  first_name: String!
  last_name: String!
  articles: [Article!]!
}

type Articles {
  id: Int!
  author_id: Int!
  title: String!
  author: Author
}
```

:::info Local and Remote Relationships

Syntactically, there are no differences between local (e.g., a relationship between two columns in the same datasource,
or an existing foreign-key relationship) or remote (a relationship across two different data sources) relationships.
Hasura DDN will automatically detect the type of relationship and make the optimal query plan accordingly.

:::

### Relationship across subgraphs

Now, imagine if the `Article` model is defined in a **different subgraph** called `subgraph_articles` and the `Author`
type and the following array relationship are part of the `default` subgraph.

We will now need to specify the **target** subgraph in the `target` section of the relationship definition as
`subgraph: subgraph_articles` as shown below:

```yaml
kind: Relationship
version:
definition:
  source: author
  name: articles
  target:
    model:
      name: Articles
      relationshipType: Array
      subgraph: subgraph_articles
  mappings:
    - source:
        fieldPath:
          - fieldName: id
      target:
        modelField:
          - fieldName: author_id
```

Next, imagine you want to query the author from the `Article` model, which is specified in the `subgraph_articles`
subgraph. You will need to specify where the `Authors` can be queried from by specifying the **subgraph** in the
`target` section of the relationship.

In this case, by specifying the subgraph as `subgraph: default` as shown below:

```yaml
kind: Relationship
version: v1
definition:
  source: article
  name: author
  target:
    model:
      name: Authors
      relationshipType: Object
      subgraph: default
  mapping:
    - source:
        fieldPath:
          - fieldName: author_id
      target:
        modelField:
          - fieldName: id
```

:::info Current limitations

1. Only types to top-level model types relationships are supported.
2. Simple top-level type field to top-level model field mapping are supported.

:::
