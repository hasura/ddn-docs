---
sidebar_position: 6
sidebar_label: Commands
description:
  "Begin executing business logic directly from your GraphQL API using Hasura Data Domain Specification commands.
  Connect to REST endpoints, custom servers or serverless functions and better manage your back-end functions."
keywords:
  - hasura commands
  - hasura dds
  - graphql api
  - business logic
  - data connector
  - rest endpoint
  - custom server
  - serverless function
  - graphql instruction
  - command configuration
seoFrontMatterUpdated: true
---

# Commands

## Introduction

Commands are backed by **functions** or **procedures** declared in a `DataConnector` allowing you to execute business
logic directly from your GraphQL API. You can use them to validate, process, or enrich some data, call another API, or
log a user in. As an example, with commands you can connect to a REST endpoint which can be your own custom server, a
public API, or a serverless function.

### Functions

Functions are used for **read** operations. They will not modify the data in the database. They can only be used to
retrieve data.

### Procedures

Procedures are used for **write** operations. They can modify the data in the database. They can be used to create,
update, or delete data.

:::info Using commands in relationships

As relationships are a querying construct, **only functions** can be used in relationships.

:::

## Metadata structure

To create a command, you need to define an object with `kind: Command` and `version: v1`. The object `definition` has
the following fields:

```yaml
kind: Command
version: v1
definition:
  name: <String>
  arguments: <ArgumentDefinition>
  outputType: <String>
  source: <CommandSourceConfiguration>
  graphql: <GraphQLConfiguration>
  description: <String>
```

| Field         | Type                                                                                | Required | Description                                            |
| ------------- | ----------------------------------------------------------------------------------- | -------- | ------------------------------------------------------ |
| `name`        | `String`                                                                            | true     | Name of the command.                                   |
| `arguments`   | [`[ArgumentDefinition]`](supergraph-modeling/common-syntax.mdx/#argumentdefinition) | false    | The argument definitions for the command.              |
| `outputType`  | `String`                                                                            | true     | The name of the return [type](./types.mdx) of command. |
| `source`      | [`CommandSourceConfiguration`](#commandsourceconfiguration)                         | true     | Source configuration for the command.                  |
| `graphql`     | [`GraphQLConfiguration`](#graphqlconfiguration)                                     | true     | GraphQL configuration for the command.                 |
| `description` | `String`                                                                            | false    | Description of the command.                            |

### CommandSourceConfiguration {#commandsourceconfiguration}

Source is an object that defines the source data connector for the command. It has the following fields:

```yaml
source:
  dataConnectorName: <String>
  dataConnectorCommand: <DataConnectorCommand>
  typeMapping: <TypeMapping>
  argumentMapping: <ArgumentMapping>
```

A command can either be backed by a function or a procedure.

| Field                  | Type                                             | Required | Description                                                                                                                               |
| ---------------------- | ------------------------------------------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `dataConnectorName`    | `String`                                         | true     | Name of the [data connector](./data-connectors.mdx) backing this command.                                                                 |
| `dataConnectorCommand` | [`DataConnectorCommand`](#dataconnectorcommand)  | true     | What command to invoke in the data connector. This will either refer to a function or a procedure.                                        |
| `typeMapping`          | [`TypeMapping`](./common-syntax.mdx#typemapping) | false    | [Type](./types.mdx) mappings for the command from the types used in the command inputs/outputs to the corresponding data connector types. |
| `argumentMapping`      | [`ArgumentMapping`](#argumentmapping)            | false    | Mappings for the argument names of the command to their corresponding data connector names.                                               |

#### DataConnectorCommand {#dataconnectorcommand}

DataConnectorCommand is an object that defines the NDC `function` or `procedure` to use for executing this command.

```yaml
dataConnectorCommand:
  # Either function OR procedure
  function: <String>
```

| Field                    | Type     | Required | Description                                                     |
| ------------------------ | -------- | -------- | --------------------------------------------------------------- |
| `function` / `procedure` | `String` | true     | Name of the function or procedure. One of these must be chosen. |

#### ArgumentMapping {#argumentmapping}

The `argumentMapping` is used to define the mapping between the `arguments` of the command and the arguments of the
`function` or `procedure` in the data connector. It has the following fields:

```yaml
argumentMappings:
  <ArgumentName>: <NDCArgumentName>
```

| Field             | Type     | Required | Description                                                                           |
| ----------------- | -------- | -------- | ------------------------------------------------------------------------------------- |
| `ArgumentName`    | `String` | true     | Name of the argument of the command                                                   |
| `NDCArgumentName` | `String` | true     | The name of the argument in function or procedure to which the `ArgumentName` maps to |

### GraphQLConfiguration {#graphqlconfiguration}

GraphQL is an object that defines how the command should be surfaced in the GraphQL API. The command can show up either
under the query root field or under the mutation root field. This can be configured as follows:

```yaml
graphql:
  rootFieldName: <String>
  rootFieldKind: <String>
```

| Field           | Type     | Required | Description                                         |
| --------------- | -------- | -------- | --------------------------------------------------- |
| `rootFieldName` | `String` | true     | The GraphQL root field name to use for the command. |
| `rootFieldKind` | `String` | true     | The type of GraphQL operation (`Query`).            |

## Examples

Below, we're creating a `Command` called `get_article_by_id` which takes an argument `article_id` of type `Int!`
(non-nullable `Int`) and returns an object of type `article` (similar to one defined
[here](/supergraph-modeling/types.mdx/#object-type-examples)).
[The command is backed by a function](/supergraph-modeling/common-syntax.mdx/#typemappings) called `get_article_by_id`
in the `db` data connector. The function returns an object with fields `id`, `title`, and `author_id`. The `id` field is
mapped to the `article_id` argument and the `title` and `author_id` fields are mapped to the `title` and `author_id`
columns respectively.

```yaml
kind: Command
version: v1
definition:
  name: get_article_by_id
  description: get article by id
  arguments:
    - name: article_id
      type: Int!
      description: id of the article
  outputType: article
  source:
    dataConnectorName: db
    dataConnectorCommand:
      function: get_article_by_id
    typeMapping:
      article:
        fieldMapping:
          article_id:
            column: id
          title:
            column: title
          author_id:
            column: author_id
    argumentMapping:
      article_id: id
  graphql:
    rootFieldName: getArticleById
    rootFieldKind: Query
```

This resulting GraphQL API will be:

```graphql
# get article by id
type Query {
  getArticleById(article_id: Int!): Article
}
```
