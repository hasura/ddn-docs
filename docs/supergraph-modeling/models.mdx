---
sidebar_position: 6
sidebar_label: Models
description:
  "Explore the concept of Models in Hasura Data Domain, your link between the data sources and the generated API. Learn
  about models, their structure, source configuration, and how they appear in the GraphQL API. Understand filterable
  fields, orderable fields, data connector types, and how to configure them. Gain insights on unique identifiers and
  their role in retrieving unique data objects from the model."
toc_max_heading_level: 4
keywords:
  - hasura models
  - data domain models
  - hasura api
  - graphql api configuration
  - source configuration
  - filterable fields
  - orderable fields
  - data connectors
  - unique identifiers
seoFrontMatterUpdated: true
---

# Models

## Introduction

A "Model" in Hasura DDN represents a collection of data objects (eg: `Users`). Models can have "operations" defined on
them so that they can be inserted, edited, deleted or fetched (with filtering, pagination, sorting, etc.). Very loosely,
you can think of models as the nouns, or "things" of your data domain.

Models as the link between a data connector and the API that Hasura generates. Models can be backed by various data
sources such as a database table, an ad-hoc SQL query, a pre-materialized view, or a custom REST or GraphQL API server.

Once a model is declared it will then often be referenced by `Relationship` objects in order to compose them with each
other or commands, and also by `Permissions` objects to control access to the data.

<details>
<summary>View an example of a model and an API query it enables</summary>

The following is an example of a model definition for a `Users` model. This model is backed by a Postgres database:

```yaml
---
kind: Model
version: v1
definition:
  name: Users
  objectType: Users
  source:
    dataConnectorName: my_pg
    collection: users
  filterExpressionType: UsersBoolExp
  orderableFields:
    - fieldName: id
      orderByDirections:
        enableAll: true
    - fieldName: name
      orderByDirections:
        enableAll: true
    - fieldName: email
      orderByDirections:
        enableAll: true
    - fieldName: createdAt
      orderByDirections:
        enableAll: true
  graphql:
    selectMany:
      queryRootField: users
    selectUniques:
      - queryRootField: usersById
        uniqueIdentifier:
          - id
    orderByExpressionType: UsersOrderBy
```

The above model definition enables the following query in the API:

```graphql
query UsersQuery {
  users(
    where: { name: { _eq: "Bob" } },
    order_by: { createdAt: Asc },
    limit: 10
  ) {
    id
    name
    email
    createdAt
  }
}
```

</details>

<details>
<summary>Check out Global IDs for relay:</summary>

A Global ID is a unique identifier for an object across the entire application, not just within a specific table or
type. Think of it as an ID which you can use to fetch any object directly, regardless of what kind of object it is. This
is different from typical database IDs, which are often guaranteed unique only within a particular table.

[//]: # "TODO: As long as it has already been fetched?"

Hasura's Global ID implementation can be used to provide options for GraphQL clients to elegantly handle caching and
data re-fetching in a predictable and standardized way.

The Global ID generated by Hasura DDN follows the
[Relay Global ID spec](https://relay.dev/graphql/objectidentification.htm).

As the example below shows, the `user` object type has a field `user_id` that uniquely identifies a user. The Global ID
for the `user` object type will be generated using the `user_id` field:

For the following request on a model which has enabled Global ID:

```graphql
{
  user_by_id(user_id: 1) {
    id // Global ID
    user_id
    name
  }
}
```

The response obtained should look like the following:

```json
{
  "data": {
    "user_by_id": {
      "id": "eyJ2ZXJzaW9uIjoxLCJ0eXBlbmFtZSI6IkFydGljbGUiLCJpZCI6eyJhcnRpY2xlX2lkIjoyfX0=",
      "user_id": 1,
      "name": "Bob"
    }
  }
}
```

Now, with the Global ID received above, the `User` object corresponding to `user_id: 1` can be retrieved, as shown
below.

```graphql
{
  node(id: "eyJ2ZXJzaW9uIjoxLCJ0eXBlbmFtZSI6IkFydGljbGUiLCJpZCI6eyJhcnRpY2xlX2lkIjoyfX0=") {
    id
    __typename
    ... on User {
      name
    }
  }
}
```

The response to the above request should identify the `User` with `user_id: 1`.

```json
{
  "node": {
    "id": "eyJ2ZXJzaW9uIjoxLCJ0eXBlbmFtZSI6IkFydGljbGUiLCJpZCI6eyJhcnRpY2xlX2lkIjoyfX0=",
    "__typename": "User",
    "name": "Bob"
  }
}
```

</details>

## Metadata structure

