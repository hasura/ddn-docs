---
sidebar_position: 2
sidebar_label: GraphQL API
description: Hasura GraphQL API - OpenDD Spec Metadata
keywords:
  - hasura
  - graphql
  - api
  - data domain metadata
  - dds metadata
---

# GraphQL API

## Introduction

[//]: # (TODO: Links to other docs when available)

Hasura DDN generates GraphQL APIs for all your data.

With the generated API, you can query, insert, update and delete data in your data domain. (Only query APIs are
available in the current release.) The benefit of defining the GraphQL API in the OpenDD Spec format is that you can
fully customize it to your needs.

To enable the GraphQL API in Hasura DDN, the following OpenDD spec metadata objects need to be defined:

- [modelGraphqlApi](#model-graphql-api): The root fields for a [model](./models.mdx) which are exposed over the GraphQL
  API.
- [scalarTypeGraphqlExpression](#scalar-type-graphql-expression): [Type](./types.mdx) names in the schema which are
  generated for data source scalars.

## Model GraphQL API

The `modelGraphqlApi` OpenDD spec object sets up GraphQL APIs on a model.

### Metadata Structure

To create a root field for a model, define an object with `"kind": "modelGraphqlApi"`. Include the model's name and at
least one select-unique query API definition:

```json
{
  "kind": "modelGraphqlApi",
  "modelName": <ModelName>,
  "selectUniques": [<SelectUniqueObject>],
  "selectMany": <SelectManyObject>,
  "filterExpressionType": <GraphQLTypeName>,
  "orderByExpressionType": <GraphQLTypeName>,
  "argumentsInputField": <ArgumentsFieldName>,
  "argumentsInputType": <ArgumentsInputType>
}
```

| Field                 | Type                                     | Required | Description                                                                                                                         |
|-----------------------|------------------------------------------|----------|-------------------------------------------------------------------------------------------------------------------------------------|
| modelName             | `String`                                 | true     | Name of the model.                                                                                                                  |
| selectUniques         | [[SelectUnique](#select-unique-queries)] | true     | Define Select unique queries.                                                                                                       |
| selectMany            | [SelectMany](#select-many-queries)       | false    | Definition to enable select many query.                                                                                             |
| filterExpressionType  | `String`                                 | false    | The type name for the `where` filter input object for select many query. The default value is of format `{ModelName}_bool_exp`.     |
| orderByExpressionType | `String`                                 | false    | The type name for the `order_by` sorting input object for select many query. The default value is of format `{ModelName}_order_by`. |
| argumentsInputField   | `String`                                 | false    | The input field name for model's arguments. Default value is `args`.                                                                |
| argumentsInputType    | `String`                                 | false    | The type name for model arguments input object. The default value is of format `{ModelName}_arguments`.                             |

:::info Note

It is not necessary to define `argumentsInputField` and `argumentsInputType` if arguments are not defined on the model.

:::

### Examples

#### Select-unique Queries {#select-unique-queries}

```json
{
  "kind": "modelGraphqlApi",
  "modelName": "User",
  "selectUniques": [
    {
      "name": "getUserById",
      "arguments": [
        {
          "name": "id",
          "type": "Int"
        }
      ],
      "outputFields": ["id", "name", "email"]
    }
  ],
  "filterExpressionType": "User_bool_exp",
  "orderByExpressionType": "User_order_by"
}
```

#### Select-many queries {#select-many-queries}

```json
{
  "kind": "modelGraphqlApi",
  "modelName": "Product",
  "selectUniques": [
    {
      "name": "getProductById",
      "arguments": [
        {
          "name": "id",
          "type": "Int"
        }
      ],
      "outputFields": ["id", "title", "description"]
    }
  ],
  "selectMany": {
    "name": "getProducts",
    "outputFields": ["id", "title", "description"]
  },
  "filterExpressionType": "Product_bool_exp",
  "orderByExpressionType": "Product_order_by"
}
```

## Scalar Type GraphQL Expression

For [Select Many](#select-many-queries) queries, it is necessary to have a `where` argument to filter
rows. The `where` argument is an input object which contains the model's type fields along with `_or`, `_and` and `_not`
operators.

The model's type field should be mapped to the data source's object type field, which must have a non-list scalar type.
For example, consider a `Post` model whose type is `post` containing the following fields:

- `post_id`: `Int`
- `content`: `String`
- `tags`: [`String`]

The `Post` model is backed by a source. The fields of the model are mapped to a `source_post` object type as per the
following:

- `post_id` -> `source_post`.`id` of type `Integer`
- `content` -> `source_post`.`content` of type null `TEXT`
- `tags` -> `source_post`.`tags` of type `[TEXT]`

In the above case, only the `post_id` and `content` fields are present in `where` argument input object.

You cannot filter objects using the `tags` field as it is mapped to an array scalar.

Each field is an input object with comparison operators as fields. These operators are defined for each scalar type in
the data source's schema.

[//]: # "TODO: refer data source schema docs when available"

```graphql
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: Integer_Scalar_Comparison_Expression_Type_Name
  content: TEXT_Scalar_Comparison_Expression_Type_Name
}
```

Using the `scalarTypeGraphqlExpression` OpenDD spec object, you can provide a custom type name for the comparison input
object of each scalar type.

### Metadata Structure

```json
{
  "kind": "ScalarTypeGraphQlExpression",
  "dataSource": <DataSourceName>,
  "scalarTypeName": <ScalarTypeName>,
  "graphqlComparisonExpressionTypeName": <GraphQLTypeName>
}
```

| Field                               | Type     | Required | Description                                   |
| ----------------------------------- | -------- | -------- | --------------------------------------------- |
| dataSource                          | `String` | true     | Name of the data source.                      |
| scalarTypeName                      | `String` | true     | Name of the scalar type                       |
| graphqlComparisonExpressionTypeName | `String` | true     | The type name for the comparison input object |

:::info Note

Defining a `scalarTypeGraphqlExpression` OpenDD spec object for a scalar type is completely optional. If not defined,
the `graphqlComparisonExpressionTypeName` will be of `{DataSource}_{ScalarTypeName}_comparison_exp` format.

:::

### Example

Consider the `Post` model example explained [above](#scalar-type-graphql-expression).

To define a comparison object type name for `TEXT` and `Integer` scalar types:

```json
[
  {
    "kind": "ScalarTypeGraphqlExpression",
    "dataSource": "my_source",
    "scalarTypeName": "TEXT",
    "graphqlComparisonExpressionTypeName": "String_Comparison_Exp"
  },
  {
    "kind": "ScalarTypeGraphqlExpression",
    "dataSource": "my_source",
    "scalarTypeName": "Integer",
    "graphqlComparisonExpressionTypeName": "Int_Comparison_Exp"
  }
]
```

Assuming the `TEXT` scalar type is exposing a `like` comparison operator and the `Integer` scalar type is exposing
`greater_than` and `less_than` operators:

```json
{
  "TEXT": {
    "comparison_operators": {
      "like": {
        "argument_type": {
          "type": "named",
          "name": "TEXT"
        }
      }
    }
  },
  "Integer": {
    "comparison_operators": {
      "like": {
        "greater_than": {
          "type": "named",
          "name": "Integer"
        },
        "less_than": {
          "type": "named",
          "name": "Integer"
        }
      }
    }
  }
}
```

And, the source scalar types are [represented](/data-domain-modeling/types.mdx#scalar-type-representation) as OpenDD
spec types as follows:

- `TEXT` -> OpenDD spec `String`
- `Integer` -> OpenDD spec `Int`

The GraphQL schema generated for the `scalarTypeGraphqlExpression` OpenDD spec objects above will appear as follows:

```graphql
input String_Comparison_Exp {
  like: String
}
input Int_Comparison_Exp {
  greater_than: Int
  less_than: Int
}
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: Int_Comparison_Exp
  content: String_Comparison_Exp
}
```

If no `scalarTypeGraphqlExpression` object defined for `TEXT` and `Integer` scalar types, then the GraphQL schema is
generated as:

```graphql
input my_source_TEXT_comparison_exp {
  like: String
}
input my_source_Integer_Comparison_Exp {
  greater_than: Int
  less_than: Int
}
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: my_source_Integer_Comparison_Exp
  content: my_source_TEXT_comparison_exp
}
```
