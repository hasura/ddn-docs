---
sidebar_position: 2
sidebar_label: DDS Metadata
description: Hasura GraphQL API - DDS Metadata
keywords:
  - hasura
  - graphql
  - api
  - data domain metadata
  - dds metadata
---

# Hasura GraphQL API: DDS Metadata

## Introduction

<!-- TODO: Links to other docs when available -->

Hasura provides automatically generated GraphQL APIs for your data domain. This is done by 
defining the domain as per the "OpenDD specification". This definition can also be called the DDS metadata.

You can define the data types, data models, relationships, permissions, and more in the DDS metadata to define your
data domain. Thus, your data domain is agnostic to the underlying database or physical layer of storage - this makes it very powerful so that a
data domain can continue to serve data in the same shape and with same authorization rules even if the underlying source is changed (say when migrating from PostgreSQL to Aurora) or using a polyglot data setup (using Mongo for reads and MySQL for writes).

:::info Automatic Metadata generation with Console and CLI

This document will help you understand how the DDS Metadata is structured and the semantics of the definition. However you will also be able to generate the
metadata automatically using the Hasura Console and LSP.
builds.

:::

A metadata is a array representation of OpenDD objects, and it would look like the following,

```json
{
  "metadata": [
    {"kind": "dataSource", ...},
    {"kind": "model", ...},
    {"kind": "modelSource", ...},
    {"kind": "objectType", ...},
    {"kind": "modelGraphqlApi", ...}
    {"kind": "modelSelectPermissions", ...},
    {"kind": "relationship", ...},
    ...
  ]
}
```

To set up the GraphQL API, you'll need to define the following DDS metadata objects:

<!-- TODO:  [DataSource] -->
<!-- TODO:  [Model] -->
<!-- TODO:  [ModelSource] -->

- [Model Graphql API](#model-graphql-api): Specify the root fields to be exposed over GraphQL API for a model.
  <!-- TODO:  [ObjectType] -->
- [Scalar Type Graphql Expression](#scalar-type-graphql-expression): Customize type names of schema generated for data
  source scalars.

## Model GraphQL API

The `modelGraphqlApi` DDS object facilitates establishing GraphQL APIs on any model and is used to define the root
fields to be exposed over GraphQL API for a model.

For instance, consider a modal named `Articles` and if you have a unique constraint on the `id` column - which is mapped
as `ArticleByID` in the source schema, you can define a modelGraphApi as follows

```json
{
  "kind": "modelGraphqlApi",
  "modelName": "Authors",
  "selectUniques": [
    {
      "queryRootField": "AuthorByID",
      "uniqueIdentifier": ["author_id"]
    }
  ]
}
```

and will be able to see the `AuthorByID` query in the GraphQL API.

and to this, if you want to query many authors as an array, you can add `selectMany` field to the `modelGraphApi` as
shown below

```json
{
  "kind": "modelGraphqlApi",
  "modelName": "Authors",
  "selectUniques": [
    {
      "queryRootField": "AuthorByID",
      "uniqueIdentifier": ["author_id"]
    }
  ],
  "selectMany": {
    "queryRootField": "users"
  }
}
```

### Metadata Structure

To define the `modelGraphqlApi` object, you will need the model's name and at least one select-unique query API
definition. Find the JSON schema for the object below.

```json
{
  "kind": "modelGraphqlApi",
  "modelName": <ModelName>,
  "selectUniques": [<SelectUniqueObject>],
  "selectMany": <SelectManyObject>,
  "filterExpressionType": <GraphQLTypeName>,
  "orderByExpressionType": <GraphQLTypeName>,
  "argumentsInputField": <ArgumentsFieldName>,
  "argumentsInputType": <ArgumentsInputType>
}
```

| Field                 | Type                                                              | Required | Description                                                                                                                         |
| --------------------- | ----------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| modelName             | `String`                                                          | true     | Name of the model.                                                                                                                  |
| selectUniques         | [[SelectUnique](/graphql-api/queries.mdx#selectunique-structure)] | true     | Define Select unique queries.                                                                                                       |
| selectMany            | [SelectMany](/graphql-api/queries.mdx#selectmany-structure)       | false    | Definition to enable select many query.                                                                                             |
| filterExpressionType  | `String`                                                          | false    | The type name for the `where` filter input object for select many query. The default value is of format `{ModelName}_bool_exp`.     |
| orderByExpressionType | `String`                                                          | false    | The type name for the `order_by` sorting input object for select many query. The default value is of format `{ModelName}_order_by`. |
| argumentsInputField   | `String`                                                          | false    | The input field name for model's arguments. Default value is `args`.                                                                |
| argumentsInputType    | `String`                                                          | false    | The type name for model arguments input object. The default value is of format `{ModelName}_arguments`.                             |

:::info Note

It is not necessary to define `argumentsInputField` and `argumentsInputType` if arguments are not defined on the model.

:::

### Examples

Find examples of the `modelGraphqlApi` DDS object for:

1. select-unique queries [here](/graphql-api/queries.mdx#examples).
2. select-many queries [here](/graphql-api/queries.mdx#examples-1).

## Scalar Type GraphQL Expression

For [Select Many](/graphql-api/queries.mdx#select-many) queries, it is necessary to have a `where` argument to filter
rows. The `where` argument is an input object which contains the model's type fields along with `_or`, `_and` and `_not`
operators.

The model's type field should be mapped to the data source's object type field, which must have a non-list scalar type.
For example, consider a `Post` model whose type is `post` containing the following fields:

- `post_id`: `Int`
- `content`: `String`
- `tags`: [`String`]

The `Post` model is backed by a source. The fields of the model are mapped to a `source_post` object type as per the
following:

- `post_id` -> `source_post`.`id` of type `Integer`
- `content` -> `source_post`.`content` of type null `TEXT`
- `tags` -> `source_post`.`tags` of type `[TEXT]`

In the above case, only the `post_id` and `content` fields are present in `where` argument input object.

You cannot filter objects using the `tags` field as it is mapped to an array scalar.

Each field is an input object with comparison operators as fields. These operators are defined for each scalar type in
the data source's schema. <!-- TODO: refer data source schema docs when available -->

```graphql
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: Integer_Scalar_Comparison_Expression_Type_Name
  content: TEXT_Scalar_Comparison_Expression_Type_Name
}
```

Using the `scalarTypeGraphqlExpression` DDS object, you can provide a custom type name for the comparison input object
of each scalar type.

### Metadata Structure

To define `scalarTypeGraphqlExpression`, you need the name of the data source and the name of the scalar type.

```json
{
  "kind": "ScalarTypeGraphQlExpression",
  "dataSource": <DataSourceName>,
  "scalarTypeName": <ScalarTypeName>,
  "graphqlComparisonExpressionTypeName": <GraphQLTypeName>
}
```

| Field                               | Type     | Required | Description                                   |
| ----------------------------------- | -------- | -------- | --------------------------------------------- |
| dataSource                          | `String` | true     | Name of the data source.                      |
| scalarTypeName                      | `String` | true     | Name of the scalar type                       |
| graphqlComparisonExpressionTypeName | `String` | true     | The type name for the comparison input object |

:::info Note

Defining a `scalarTypeGraphqlExpression` DDS object for a scalar type is completely optional. If not defined, the
`graphqlComparisonExpressionTypeName` will be of `{DataSource}_{ScalarTypeName}_comparison_exp` format.

:::

### Example

Consider the `Post` model example explained [above](#scalar-type-graphql-expression).

To define a comparison object type name for `TEXT` and `Integer` scalar types:

```json
[
  {
    "kind": "scalarTypeGraphqlExpression",
    "dataSource": "my_source",
    "scalarTypeName": "TEXT",
    "graphqlComparisonExpressionTypeName": "String_Comparison_Exp"
  },
  {
    "kind": "scalarTypeGraphqlExpression",
    "dataSource": "my_source",
    "scalarTypeName": "Integer",
    "graphqlComparisonExpressionTypeName": "Int_Comparison_Exp"
  }
]
```

Assuming the `TEXT` scalar type is exposing a `like` comparison operator and the `Integer` scalar type is exposing
`greater_than` and `less_than` operators:

```json
{
  "TEXT": {
    "comparison_operators": {
      "like": {
        "argument_type": {
          "type": "named",
          "name": "TEXT"
        }
      }
    }
  },
  "Integer": {
    "comparison_operators": {
      "like": {
        "greater_than": {
          "type": "named",
          "name": "Integer"
        },
        "less_than": {
          "type": "named",
          "name": "Integer"
        }
      }
    }
  }
}
```

And, the source scalar types are [represented](/data-domain-modeling/types.mdx#scalar-type-representation) as DDS types
as follows:

- `TEXT` -> DDS `String`
- `Integer` -> DDS `Int`

The GraphQL schema generated for the `scalarTypeGraphqlExpression` DDS objects above will appear as follows:

```graphql
input String_Comparison_Exp {
  like: String
}
input Int_Comparison_Exp {
  greater_than: Int
  less_than: Int
}
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: Int_Comparison_Exp
  content: String_Comparison_Exp
}
```

If no `scalarTypeGraphqlExpression` object defined for `TEXT` and `Integer` scalar types, then the GraphQL schema is
generated as:

```graphql
input my_source_TEXT_comparison_exp {
  like: String
}
input my_source_Integer_Comparison_Exp {
  greater_than: Int
  less_than: Int
}
input Where_Filter_Input {
  _and: [Where_Filter_Input]
  _or: [Where_Filter_Input]
  _not: Where_Filter_Input

  # Model fields
  post_id: my_source_Integer_Comparison_Exp
  content: my_source_TEXT_comparison_exp
}
```
