---
sidebar_position: 4
sidebar_label: Types
description: OpenDD Spec Types
keywords:
  - hasura
  - graphql
  - data domain
  - types
---

# OpenDD Spec Types

## Introduction

Types are the building blocks of data structures and algorithms and form the foundation of software development and
data management. In the Open Data Domain Specification in Hasura DDN, they serve as the fundamental elements
that define the structure and operations of your data.

Being able to define types in your OpenDD spec data domain is beneficial because it provides you with the
flexibility to define them separately from the types in your data source.

The specification employs a concrete type system that includes both primitive types and user-defined types. All
subsequent layers, such as operators, models, and commands, are defined in terms of these types.

The types can be one of the following:

| OpenDD Type | Description                                                             |
|-------------|-------------------------------------------------------------------------|
| Primitive   | These are basic types such as `Int`, `Float`, `Boolean`, or `String`    |
| Container   | These are types that can hold other types such as `Nullable` or `Array` |
| Custom      | These are user-defined types, such as `NewType` or `ObjectType`         |

The spec also allows you to map existing data source scalars to types in your data domain.

## Description

**Container types are types that can contain other primitive or custom types.** Currently, container types can be
nullable or arrays. Nullability in your data source types are represented using the `Nullable` container type.

You can also define custom types by either aliasing existing types (such as primitives or custom), or you can define a
type with fields. In turn, the fields themselves can be a primitive or another custom type.

[//]: # (TODO: Add reference to scalars ðŸ‘‡ when data sources are documented)

[Scalar type representation](#scalar-type-representation) helps in mapping data source scalars to any of the OpenDD spec
primitive, container or custom types.

## Primitive and container types

Primitive types don't have any metadata structure and simply use the names `Int` / `Float` / `Boolean` / `String`
directly.

Container types are defined as:

```json
{
  "Nullable": <Type>
}
```

```json
{
  "Array": <Type>
}
```

| Value  | Description                                                                                                           |
| ------ | --------------------------------------------------------------------------------------------------------------------- |
| `Type` | String in case of primitive or custom types. An object in the case of container types. (Link to JSONSchema of `Type`) |

## NewType

In the OpenDD spec, you can alias types by defining an object with `"kind": "NewType"`. To define a `NewType` you
need to define a name and an optional representation. This `representation` field can refer to any existing
primitive, container or custom type and can be a string or an object.

### Metadata structure

```json
{
    "kind": "newType",
    "name": "<TypeName>",
    "representation": <Type>
}
```

| Field          | Type     | Required | Description                                                                                                           |
| -------------- | -------- | -------- | --------------------------------------------------------------------------------------------------------------------- |
| name           | `String` | true     | Name of the type                                                                                                      |
| representation | `Type`   | false    | String in case of primitive or custom types. An object in the case of container types. (Link to JSONSchema of `Type`) |

[//]: # (TODO link above)

### Examples

```json
{
  "kind": "newType",
  "name": "UUID",
  "representation": "String"
}
```

```json
[
  {
    "kind": "newType",
    "name": "Tag",
    "representation": "String"
  },
  {
    "kind": "newType",
    "name": "Tags",
    "representation": {
      "Array": "Tag"
    }
  }
]
```

```json
{
  "kind": "newType",
  "name": "OpaqueDate"
}
```

## Object types

In the OpenDD spec, completely new types can be created by defining an object with `"kind": "objectType"`. You need to
also define a name and the fields for this type.

### Metadata structure

```json
{
  "kind": "objectType",
  "name": "<TypeName>",
  "fields": [
    {
      "name": "field1",
      "type": <Type>
    },
    {
      "name": "field2",
      "type": <Type>
    }
  ]
}
```

| Field  | Type      | Required | Description      |
| ------ | --------- | -------- | ---------------- |
| name   | `String`  | true     | Name of the type |
| fields | `[Field]` | true     | List of fields   |

#### Field

| Field | Type     | Required | Description                                                                                                                              |
| ----- | -------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| name  | `String` | true     | Name of the field                                                                                                                        |
| type  | `Type`   | true     | Type of the field. String in case of primitive or custom types. An object in the case of container types. (Link to JSONSchema of `Type`) |

[//]: # (TODO link above)

### Examples

```json
{
  "kind": "objectType",
  "name": "author",
  "fields": [
    {
      "name": "author_id",
      "type": "Int"
    },
    {
      "name": "first_name",
      "type": "String"
    },
    {
      "name": "last_name",
      "type": "String"
    }
  ]
}
```

## Scalar type representation

A scalar type from a data source can be represented as an OpenDD spec type by defining an object with `"kind":
"scalarTypeRepresentation"`. To define a scalar type representation, you need to have a data source name, a
scalar name and a type representation. This `representation` can refer to any existing primitive, container, or
custom type and can be a string or an object.

It is necessary to map all available scalars from a data source to OpenDD spec types.

### Metadata structure

```json
{
  "kind": "scalarTypeRepresentation",
  "dataSource": "<DataSourceName>",
  "scalarType": "<ScalarTypeName>",
  "representation": <Type>
}
```

| Field          | Type     | Required | Description                                                                                                       |
| -------------- | -------- | -------- | ----------------------------------------------------------------------------------------------------------------- |
| dataSource     | `String` | true     | Name of the data source                                                                                           |
| scalarType     | `String` | true     | Name of the scalar type from the data source                                                                      |
| representation | `Type`   | true     | String in case of primitive or custom types. An object in case of container types. (Link to JSONSchema of `Type`) |

### Examples

1. Mapping a `text` scalar type from `my_source` source to a primitive `String` type.

```json
{
  "kind": "scalarTypeRepresentation",
  "dataSource": "my_source",
  "scalarType": "text",
  "representation": "String"
}
```

2. Mapping a PostgreSQL scalar `geography` to a custom object type.

```json
[
  {
    "kind": "objectType",
    "name": "Geography",
    "fields": [
      {
        "name": "type",
        "type": "String"
      },
      {
        "name": "coordinates",
        "type": {
          "Array": "Float"
        }
      }
    ]
  },
  {
    "kind": "scalarTypeRepresentation",
    "dataSource": "pg_source",
    "scalarType": "geography",
    "representation": "Geography"
  }
]
```
