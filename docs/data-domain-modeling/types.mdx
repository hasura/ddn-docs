---
sidebar_position: 4
sidebar_label: Types
description: OpenDD Types
keywords:
  - hasura
  - graphql
  - data domain
  - types
---

# OpenDD Types

## Introduction

In the Open Data Domain Specification in Hasura DDN, types serve as the fundamental elements that define the structure
of your data.

Being able to define types in your data domain is beneficial because it provides you with the flexibility to define them
separately from the types in your data source.

The specification employs a concrete type system that includes both primitive types and user-defined types. All
subsequent layers, such as operators, models, and commands, are defined in terms of these types.

[//]: # "Link out above para"

The types can be one of the following:

| OpenDD Type | Description                                                             |
| ----------- | ----------------------------------------------------------------------- |
| Primitive   | These are basic types such as `Int`, `Float`, `Boolean`, or `String`    |
| Container   | These are types that can hold other types such as `Nullable` or `Array` |
| Custom      | These are user-defined types, such as `ScalarType` or `ObjectType`      |

The spec also allows you to map existing data source scalars to types in your data domain.

## Description

**Container types are types that can contain other primitive or custom types.** Currently, container types can be
nullable or arrays. Nullability in your data source types are represented using the `Nullable` container type.

You can also define custom types by either aliasing existing types (such as primitives or custom), or you can define a
type with fields. In turn, the fields themselves can be a primitive or another custom type.

[//]: # "TODO: Add reference to scalars ðŸ‘‡ when data sources are documented"

[Scalar type representation](#scalar-type-representation) helps in mapping data source scalars to any of the OpenDD
primitive, container or custom types.

## Primitive and container types

Primitive types don't have any metadata structure and simply use the names `Int` / `Float` / `Boolean` / `String`
directly.

Container types are defined as:

```json
{
  "Nullable": <Type>
}
```

```json
{
  "Array": <Type>
}
```

| Value  | Description                                                                                                           |
| ------ | --------------------------------------------------------------------------------------------------------------------- |
| `Type` | String in case of primitive or custom types. An object in the case of container types. (Link to JSONSchema of `Type`) |

## ScalarType

In the OpenDD spec, you can alias types by defining an object with `"kind": "ScalarType"`. To define a `ScalarType` you
need to define a name and an optional representation. This `representation` field can refer to any existing primitive,
container or custom type and can be a string or an object.

### Metadata structure

```json
{
    "kind": "ScalarType",
    "name": "<TypeName>",
    "representation": <Type>
}
```

| Field          | Type     | Required | Description                                                                                                           |
| -------------- | -------- | -------- | --------------------------------------------------------------------------------------------------------------------- |
| name           | `String` | true     | Name of the type                                                                                                      |
| representation | `Type`   | false    | String in case of primitive or custom types. An object in the case of container types. (Link to JSONSchema of `Type`) |

[//]: # "TODO link above"

### Examples

```json
{
  "kind": "ScalarType",
  "name": "UUID",
  "representation": "String"
}
```

```json
[
  {
    "kind": "ScalarType",
    "name": "Tag",
    "representation": "String"
  },
  {
    "kind": "ScalarType",
    "name": "Tags",
    "representation": {
      "Array": "Tag"
    }
  }
]
```

```json
{
  "kind": "ScalarType",
  "name": "OpaqueDate"
}
```

## Object types

In the OpenDD spec, completely new types can be created by defining an object with `"kind": "ObjectType"`. You need to
also define a name and the fields for this type.

### Metadata structure

```json
{
  "kind": "ObjectType",
  "name": "<TypeName>",
  "fields": [
    {
      "name": "field1",
      "type": <Type>
    },
    {
      "name": "field2",
      "type": <Type>
    }
  ]
}
```

| Field  | Type      | Required | Description      |
| ------ | --------- | -------- | ---------------- |
| name   | `String`  | true     | Name of the type |
| fields | `[Field]` | true     | List of fields   |

#### Field

| Field | Type     | Required | Description                                                                                                                              |
| ----- | -------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| name  | `String` | true     | Name of the field                                                                                                                        |
| type  | `Type`   | true     | Type of the field. String in case of primitive or custom types. An object in the case of container types. (Link to JSONSchema of `Type`) |

[//]: # "TODO link above"

### Examples

```json
{
  "kind": "ObjectType",
  "name": "author",
  "fields": [
    {
      "name": "author_id",
      "type": "Int"
    },
    {
      "name": "first_name",
      "type": "String"
    },
    {
      "name": "last_name",
      "type": "String"
    }
  ]
}
```

## Scalar type representation

A scalar type from a data source can be represented as an OpenDD type by defining an object with
`"kind": "DataConnectorScalarRepresentation"`. To define a scalar type representation, you need to have a data source
name, a scalar name and a type representation. This `representation` can refer to any existing primitive, container, or
custom type and can be a string or an object.

It is necessary to map all available scalars from a data source to OpenDD types.

### Metadata structure

```json
{
  "kind": "DataConnectorScalarRepresentation",
  "dataSource": "<DataSourceName>",
  "scalarType": "<ScalarTypeName>",
  "representation": <Type>
}
```

| Field          | Type     | Required | Description                                                                                                       |
| -------------- | -------- | -------- | ----------------------------------------------------------------------------------------------------------------- |
| dataSource     | `String` | true     | Name of the data source                                                                                           |
| scalarType     | `String` | true     | Name of the scalar type from the data source                                                                      |
| representation | `Type`   | true     | String in case of primitive or custom types. An object in case of container types. (Link to JSONSchema of `Type`) |

### Examples

1. Mapping a `text` scalar type from `my_source` source to a primitive `String` type.

```json
{
  "kind": "DataConnectorScalarRepresentation",
  "dataSource": "my_source",
  "scalarType": "text",
  "representation": "String"
}
```

2. Mapping a PostgreSQL scalar `geography` to a custom object type.

```json
[
  {
    "kind": "ObjectType",
    "name": "Geography",
    "fields": [
      {
        "name": "type",
        "type": "String"
      },
      {
        "name": "coordinates",
        "type": {
          "Array": "Float"
        }
      }
    ]
  },
  {
    "kind": "DataConnectorScalarRepresentation",
    "dataSource": "pg_source",
    "scalarType": "geography",
    "representation": "Geography"
  }
]
```
