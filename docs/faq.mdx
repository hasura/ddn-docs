---
sidebar_position: 11
sidebar_label: FAQ
description: Learn all about Hasura DDN with our FAQs covering everything from architecture, compatibility, performance, to pricing and data connections. Understand how Hasura DDN is revolutionizing API management for modern applications.
keywords:
  - hasura ddn
  - hasura api management
  - opendd spec
  - hasura cloud
  - native data connectors
  - hasura runtime engine
  - hasura cli
  - hasura ddn faq
  - ddn api speed
  - hasura v2
seoFrontMatterUpdated: true
---

# Hasura FAQ

## What is Hasura DDN?

Hasura DDN represents a fundamental shift in how we think about data domains and is a bold response to the evolved
requirements of our users. With Hasura DDN, we are introducing a new approach to API management that is designed to
provide, both in developer workflow and final product: a faster, more powerful, agile, and scalable solution for
building modern applications.

Based around the new Open Data Domain Specification, (OpenDD spec), Hasura DDN allows an entire API layer, connecting to
almost any conceivable data source, to be declaratively scaffolded and then deployed almost instantaneously to Hasura
Cloud to deliver ultra-performant production-grade APIs at the edge. It's a concept we call, The **data supergraph**.

## Will Hasura DDN be compatible with Hasura v1/v2?

The default generated GraphQL schema of Hasura DDN is compatible with v2 schemas. However, Hasura DDN is a complete
re-architecture of the Hasura platform and we will provide migration tools to move v2 metadata to DDN.

## Will Hasura v2 be supported after Hasura DDN is released?

We will still support, maintain and improve Hasura v2 for the near future and will be providing migration tools to move
Hasura v2 deployments to DDN. At some point, when Hasura DDN has achieved feature parity with v2, we will begin the v2
deprecation process and keep the community notified and informed. To be clear, Hasura DDN is the future of Hasura and we
will be investing heavily in it going forward.

## What is the general architecture of Hasura DDN?

**Open Data Domain Specification (OpenDD Spec):** At the heart of Hasura API development is the OpenDD
spec. It is a specification that defines the structure of metadata used by the Hasura runtime engine. Think of the
specification as an API contract generator helping you to reason about your data domains and model your applications
and APIs. [Learn more](/data-domain-modeling/overview.mdx).

**Native Data Connector (NDC) Specification:** The NDC specification focuses on enabling the community to build data
connector agents. It supports building high-quality integrations for almost any conceivable data source, offering
features like native queries, push-down capabilities, and connection pooling. NDCs help streamline the integration of
diverse data sources into APIs. [Learn more](/connectors/overview.mdx).

**Hasura Runtime Engine:** The Hasura Engine is responsible for processing and serving APIs based on the provided
metadata. It has been restructured to work declaratively with metadata, utilizing the OpenDD spec. This engine can serve
production-grade APIs from the edge with extremely high performance, as it fetches metadata on a per-request basis and
benefits from vastly improved startup times. And it's built from the ground up with Rust.

**Hasura Cloud:** The cloud layer in Hasura DDN, Hasura Cloud, introduces the Data Delivery Network (DDN) for global API
performance and availability. This layer also facilitates secure tunnels for local development using Hasura Secure
Connect and also offers tools for managing projects.

**Hasura CLI:** The new Hasura CLI (Command-Line Interface), rebuilt in Rust, serves as a powerful tool for developers
to interact with the Hasura platform. It allows users to create projects, manage metadata, create builds, and deploy
production APIs both locally and in the cloud, easily. [Learn More](/cli/overview.mdx)

**Hasura Console:** The Hasura Console offers a graphical interface for viewing metadata. Users can also run queries on
their API with GraphiQL.

**Namespaces:** Namespaces introduce a module system for metadata. They allow multi-team organizations working on a
Hasura project to segment access to different metadata objects. A project's metadata is the amalgamation of metadata
objects from all its namespaces, and each namespace can be accessed and updated independently. It also helps in
avoiding conflicts when there are, for example, tables with the same names in different data sources.
[Learn more](/ci-cd/subgraphs.mdx)

## What is the difference between Hasura v2 and DDN metadata

In practical terms, the Hasura v2 metadata system was designed to draw extra information directly from the data source,
specifically details such as columns and fields.

This meant that whenever the Hasura GraphQL Engine was initialized, it had to probe or "introspect" the data source's
schema to create a GraphQL schema. This introduced delays at start-up especially if the data source was large or if
there were network issues.

OpenDD metadata operates differently as it is inherently self-contained and exists independent of any data source. This
leads to sub-second startup and deploy times and ensures consistency as the system is no longer polling an underlying
data source for schema information which may have changed.

The OpenDD metadata has full coverage and details like fields and their respective types are predefined and embedded
within metadata. This design choice removes the need for the system to check the data source schema every time during
startup to shape a GraphQL schema. Instead, this introspection or probing of the data source's structure is now carried
out during the metadata creation, or build phase. This leads to massively improved startup times and ensures that the
metadata is consistent and self-contained.

## Is a Hasura DDN API faster than a Hasura v2 API?

Yes. Hasura DDN includes significant performance improvements compared to its predecessors. The optimizations
implemented in Hasura DDN aim to provide faster response times and improved scalability, ensuring a smooth and efficient
experience for your applications and users.

## What will be the benefit for me, the developer?

- A single spec to define your whole API.
- Connect to any data with Native Data Connectors (NDCs).
- Deploy with lightning speed and sub-second CI/CD.
- Work better with your team with improved version control and collaboration features.
- Unparalleled performance at any scale with optimized query execution and caching mechanisms.
- Serverless runtime system for improved efficiency and reduced latency.
- Benefit from Rust's performance and ecosystem in the refactored Hasura runtime engine.
- Access a global edge network for low-latency, high-performance APIs with the Data Delivery Network (DDN).

## What CI/CD features does Hasura DDN offer?

**Sub-Second CI/CD:** Hasura brings sub-second CI/CD capabilities, enabling developers to test and validate changes
rapidly.

**CLI-Controlled Deployments:** The Hasura Command-Line Interface (CLI) plays a central role in controlling and managing
deployments. It allows developers to create builds and promote them to production. This CLI-centric approach simplifies
the deployment process. [Learn more](/cli/overview.mdx)

**Builds and Project Shares:** With Hasura, metadata states are represented as builds. Once a build is thoroughly tested
and validated, it can be applied to a project and made available to API consumers globally. This separation of build and
production steps ensures a smoother transition from development to production.

**Extremely Fast Builds:** Hasura also introduces cloud innovations that allow metadata builds to be created in under
one second, regardless of the number of models. This means that deploying even a large number of models is a swift and
seamless process and developers can rapidly test multiple deployments within a day.

**Zero Downtime Rollouts:** With Hasura, going to production is facilitated without restarts and with zero downtime.
This ensures that your API remains available to users while updates are being applied.

**Metadata Version Control:** Hasura includes in-product metadata version control. Each build is associated with a
unique build ID, making it easier to track and manage different versions of your metadata. This enhances transparency
and auditability during the deployment process.

## How does Hasura DDN connect to data sources?

Native Data Connectors (NDC) are a framework introduced in Hasura DDN that enables developers to build custom data
connector agents. These agents facilitate the integration between Hasura and external data sources, allowing Hasura to
seamlessly interact with a wide range of databases, services, and APIs. NDCs can be built for almost any conceivable
source of data and are the only way to connect to data sources in Hasura DDN. [Learn more](/connectors/overview.mdx)

## Is Hasura DDN open source?

Some elements of Hasura DDN will be open-sourced and some will not.

## Will pricing be different with Hasura DDN?

Yes. The pricing for Hasura DDN is determined by the number of models in your metadata which reflects the value you gain
from the product.

Unlike other vendors in this field, our pricing model separates pricing from the usage of underlying infrastructure.
This approach ensures that you can focus on your applications without concerns about traffic scale, computing resources,
or networking requirements, as Hasura DDN Pricing is designed to free you from those concerns.

The Hasura DDN pricing structure empowers you to easily measure and manage your expenses, all without the need to
monitor factors such as vCPU, RAM, API requests, peak traffic, cache size, concurrent subscriptions, and more.

## Will Hasura continue supporting existing plans, specifically, the Free and Professional plans?

Yes. We are committed to maintaining & supporting the Free and Professional plans to ensure there is no disruption
for our users.


## Why Rust over Haskell?

We have a lot of love for Haskell. It's a beautiful language that we have been using for the Hasura engine since the
beginning, and will still be using it on Hasura v2. Without going into the weeds in a FAQ, we wanted to benefit from
Rust's performance, ecosystem and community for DDN. Rust is a modern, high-performance, and memory-safe language. It is
also gaining a lot of traction in the cloud-native space, and we are excited to be using it for the majority of the
Hasura DDN codebase.

## What is the timeline for Hasura DDN?

The timeline for Hasura DDN may vary depending on the specific features and enhancements being developed. We are
committed to delivering a stable and reliable release, and the team is working diligently to ensure a timely rollout.
For the most up-to-date information on the timeline, we recommend referring to our
[official announcements and releases](https://hasura.io/community/).

## Authoring metadata looks hard, how can I get started?

The Hasura LSP (Language Server Protocol)
[plugin for VSCode](https://marketplace.visualstudio.com/items?itemName=HasuraHQ.hasura) and other editors will help you
get started with authoring if you want to do it by hand. It includes autocomplete and validation for the metadata file.

[//]: # "## Will Event and Scheduled Triggers be supported in Hasura DDN?"
[//]: # "Will Actions be supported in Hasura DDN?"
[//]: # "## What are the key differences of Hasura V2 compared to Hasura DDN?"
[//]: # "## What are the main changes to the Hasura Console?"
[//]: # "## What are the main changes to the Hasura CLI?"
[//]: # "## Why would I want to switch to DDN?"
[//]: # "## Can Hasura DDN work without Hasura Cloud, can I self-host the runtime engine?"



[//]: # (## Why has Hasura DDN adopted features from the Relay GraphQL framework?)
[//]: # ()
[//]: # (Relay is the best way to solve problems with scaling frontend teams. Traditional methods, like backend-for-frontend,)
[//]: # (which creates separate backend services to be consumed by specific frontend applications or interfaces, often)
[//]: # (introduced more problems, especially in data fetching and state management. Relay addresses these by allowing)
[//]: # (components to define their data needs, ensuring they only access explicitly requested data.)