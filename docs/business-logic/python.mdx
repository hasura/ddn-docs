---
sidebar_position: 4
sidebar_label: Python
description: "Explore how to mutate data using the Python data connector."
keywords:
  - hasura
  - ddn
  - hasura ddn
  - python
  - custom logic
  - api management
  - graphql api
---

import Thumbnail from "@site/src/components/Thumbnail";

# Custom Business Logic via Python

## Introduction

The [Python Lambda Connector](https://github.com/hasura/ndc-python-lambda) can be added to any project to incorporate
custom business logic directly into your supergraph.

This can be used to enrich data returned to clients, or to write custom mutations in Python.

:::info Prerequisites

If you've never used Hasura DDN, we recommend that you first go through the
[getting started](/getting-started/overview.mdx). ðŸ˜Š

:::

## Functions or Procedures

Python functions exported from a file in the [Python Lambda Connector](https://github.com/hasura/ndc-python-lambda) will
then be available from your Hasura DDN GraphQL API in the form of either **functions** or **procedures**.

In Hasura metadata, **functions** are used for read operations. They will not modify the data in the database and can
only be used to retrieve data.

Conversely, **procedures** are used for write operations. They can modify the data in the database and can be used to
create, update, or delete data.

The distinction is important in metadata because it allows the system to know what types to expect for arguments and
return values.

## Add the Python connector to a project

### Step 1. Initialize the Python Lambda connector

Let's begin by initializing the connector on our project. In the example below, you'll see some familiar flags with new
values being passed to them. We'll call this `my_python` and use the `hasura/python` connector from the connector hub:

```bash title="From the root of your project, run:"
ddn connector init my_python \
  --subgraph my_subgraph/subgraph.yaml \
  --hub-connector hasura/python \
  --configure-port 8085
```

In this command, we're passing a few important values.

**Connector name**

We're naming the connector `my_python` in this example, but you can call it whatever makes sense to you.

**Connector: `--hub-connector`**

We're specifying that this connector should be the: `hasura/python`, connector listed in the
[Connector Hub](https://hasura.io/connectors/python-lambda).

**Port: `configure-port`**

We're specifying the port to run the connector on. This is important to avoid port collisions with other connectors or
services which you might have running on your machine. Remember to use a different port for each connector you may have
running.

:::tip Best practices

Importantly, a data connector can only connect to one data source.

The project will be kept organized with each data connector's configuration located in a relevant subgraph directory. In
this example the CLI will create a `my_subgraph/connector/my_python` directory if it doesn't exist. You can also change
this directory by passing a `--dir` flag to the CLI.

We recommend that the name of the connector and the directory in which the configuration is stored, `my_python` in this
example, should match for convenience and clarity sake.

In subsequent steps, when running your connector locally, it's critical to ensure the port value matches the connection
string you provide in your subgraph's `.env.my_subgraph` file.

:::

#### What did this do?

This command created the following file structure in a `my_subgraph/connector/my_python` directory, with the
`functions.py` file being your connector's entrypoint:

```bash
.
â”œâ”€â”€ .ddnignore
â”œâ”€â”€ .env.cloud
â”œâ”€â”€ .env.local
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .hasura-connector
â”‚  â”œâ”€â”€ ...
â”œâ”€â”€ compose.yaml
â”œâ”€â”€ connector.cloud.yaml
â”œâ”€â”€ connector.local.yaml
# highlight-start
â”œâ”€â”€ functions.py
# highlight-end
â””â”€â”€ requirements.txt
```

### Step 2. Add the DataConnectorLink

As with any other connector, we'll now need to create the `DataConnectorLink` which will translate our Python functions
into `hml` commands that can be exposed as queries and mutations via our GraphQL API. Create this using:

```bash title="Run the following from the root of your project:"
ddn connector-link add my_python \
  --subgraph my_subgraph/subgraph.yaml \
  --configure-host http://local.hasura.dev:8085 \
  --target-env-file my_subgraph/.env.my_subgraph.local
```

The `--configure-host` convenience flag added the read and write URL for the connection to the `.env.my_subgraph` file
for us.

```env title="Example .env.my_subgraph file"
MY_SUBGRAPH_MY_PYTHON_READ_URL="http://local.hasura.dev:8085"
MY_SUBGRAPH_MY_PYTHON_WRITE_URL="http://local.hasura.dev:8085"
```

These keys are already referenced in `my_subgraph/metadata/my_python/my_python.hml`.

### Step 3. Install pip package dependencies

Let's install any necessary dependencies:

```bash title="Change to the connector directory and install dependencies:"
cd my_subgraph/connector/my_python && pip3 install -r requirements.txt
```

Then, from the `my_python` directory run this command to load environment variables from the `. env.local` file, start
the connector, and watch for any changes:

On Mac or Linux:

```bash
watchmedo auto-restart --patterns="*.py" --recursive -- sh -c "export \$(grep -v '^#' .env.local | xargs) && python3 functions.py serve"
```

On Windows:

```bash
watchmedo auto-restart --patterns="*.py" --recursive -- powershell -Command "Get-Content .env.local | ForEach-Object { if ($_ -notmatch '^#') { $var = $_.Split('='); Set-Item \"env:$($var[0])\" $var[1] } }; python3 functions.py serve"
```

:::warning Python version

The `hasura/python` connector requires [Python](https://www.python.org/downloads/) version `>=3.11`. Please make sure
you have the correct version installed.

:::

### Step 4. Write business logic

The template code that ships with the Python Lambda connector provides some simple examples to help explain how it
works. We can replace those example functions for now.

In this simple example, we're going to transform a timestamp with timezone (eg: "2024-03-14T08:00:00Z") into a nicely
formatted version for humans, eg: "8am, Thursday, March 14th, 2024."

We'll replace the all the default functions in our `functions.py` file with the following:

```python
from hasura_ndc import start
from hasura_ndc.function_connector import FunctionConnector
from datetime import datetime # Don't forget to import datetime at the top of the file!

connector = FunctionConnector()

@connector.register_query
async def format_timezone_data(date_string: str) -> str:
    date = datetime.fromisoformat(date_string)

    day = date.day
    nth = lambda d: "th" if 11 <= d <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(d % 10, "th")

    hours = date.hour
    ampm = "pm" if hours >= 12 else "am"
    hour = hours % 12 or 12

    day_of_week = date.strftime("%A")
    month = date.strftime("%B")
    year = date.year

    return f"{hour}{ampm}, {day_of_week}, {month} {day}{nth(day)}, {year}."


if __name__ == "__main__":
    start(connector)
```

As this is a Python project, you can install any dependency!

### Step 5. Track the new function

To add our function, similar to how we added our individual tables earlier, we can use the following to generate the
related Hasura metadata:

```bash
ddn connector-link update my_python \
  --subgraph my_subgraph/subgraph.yaml \
  --env-file my_subgraph/.env.my_subgraph.local \
  --add-all-resources
```

### Step 6. Create a new API build and test

Next, let's create a new build of our supergraph:

```bash
ddn supergraph build local \
  --output-dir engine \
  --subgraph-env-file my_subgraph:my_subgraph/.env.my_subgraph.local
```

:::tip Start your engines!

Want to test your supergraph? Don't forget to start your GraphQL engine using the following command.

```bash title="From the root of your project, run:"
ddn run docker-start
```

This reads the `docker-start` script from the context config at `.hasura/context.yaml` and starts your Hasura engine,
any connectors, and observability tools.

:::

You should see your command available, along with its documentation, in the GraphiQL explorer which you should be able
to access at
[`https://console.hasura.io/local/graphql?url=http://localhost:3000`](https://console.hasura.io/local/graphql?url=http://localhost:3000).

```graphql title=" You can then test your new command with the following query:"
query MyQuery {
  formatTimezoneDate(dateString: "2024-03-14T08:00:00Z")
}
```

<Thumbnail
  src="/img/get-started/beta/console_business_logic_demo_query.png"
  alt="Demo Business Logic query"
  width="1000px"
/>

:::tip Privacy settings in some browsers

Your browser settings or privacy tools may prevent the Console from accessing your local Hasura instance. This could be
due to features designed to protect your privacy and security. Should you encounter one of these issues, we recommend
disabling these settings for the `console.hasura.io` domain.

[Chrome](https://www.google.com/chrome/) and [Firefox](https://www.mozilla.org/en-US/firefox/new/) are the recommended
browsers for the best experience with the Hasura Console including for local development.

:::

:::note Running Python in Docker

As you can see we're running Python and your functions directly on your own machine. You can also run your functions in
a Docker container along with your other Hasura services. The `connector init` command created a `Dockerfile` and a
`compose.yaml` file for you, so all you would need to do would be to:

- Make sure your port in your connector's `.env.local` and the one referenced in the
  `my_subgraph/connector/my_python/compose.yaml` file `ports:published` and `ports:target` fields match and don't
  conflict with any other services you may need to run.
- Add the Python Lambda connector compose file to the main compose file in the root of the project if you want them to
  start all together. Eg:

```yaml title="At the top of the root compose.yaml"
include:
  - path: my_subgraph/connector/my_python/compose.yaml
```

:::
