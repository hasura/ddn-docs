---
sidebar_position: 3
sidebar_label: TypeScript
description: "Explore how to mutate data using the TypeScript data connector."
keywords:
  - hasura
  - ddn
  - hasura ddn
  - typescript
  - custom logic
  - api management
  - graphql api
---

# Custom Business Logic via TypeScript

## Introduction

The [Node.js Lambda Connector](https://github.com/hasura/ndc-nodejs-lambda) can be added to any project to incorporate
custom business logic directly into your supergraph.

This can be used to enrich data returned to clients, or to write custom mutations in TypeScript with Node.js.

:::info Prerequisites

If you've never used Hasura DDN, we recommend that you first go through the
[getting started](/getting-started/overview.mdx). ðŸ˜Š

:::

## Functions or Procedures

TypeScript functions exported from a file in the [Node.js Lambda Connector](https://github.com/hasura/ndc-nodejs-lambda)
will then be available from your Hasura DDN GraphQL API in the form of either **functions** or **procedures**.

In Hasura metadata, **functions** are used for read operations. They will not modify the data in the database and can
only be used to retrieve data.

Conversely, **procedures** are used for write operations. They can modify the data in the database and can be used to
create, update, or delete data.

The distinction is important in metadata because it allows the system to know what types to expect for arguments and
return values.

## Add the TypeScript connector to a project

### Step 1. Initialize the TypeScript connector

Let's begin by initializing the connector on our project. In the example below, you'll see some familiar flags with new
values being passed to them. We'll call this the `ts_connector` and use the `hasura/nodejs` connector from the connector
hub:

```bash
ddn connector init my_ts \
  --subgraph my_subgraph/subgraph.yaml \
  --hub-connector hasura/nodejs \
  --configure-port 8083 \
  --add-to-compose-file docker-compose.hasura.yaml
```

With this `connector init` command, we're passing a few important values.

**Connector name**

We're naming the connector `my_ts` in this example, but you can call it whatever makes sense to you.

**Subgraph: `--subgraph`**

We're specifying the subgraph that this connector will be added to using the `--subgraph` flag.

**Connector: --hub-connector**

We're specifying that this connector should be the `hasura/nodejs` connector listed in the
[Connector Hub](https://hasura.io/connectors/mongodb).

**Port: `configure-port`**

We're specifying the port to run the connector on. This is important to avoid port collisions with other connectors or
services which you might have running on your machine. Remember to use a different port for each connector you may have
running.

**Compose file: `--add-to-compose-file`**

We're specifying the `--add-to-compose-file` flag to add the connector's **own** Docker compose file to the main
`docker-compose.hasura.yaml` file. This is for convenience and allows us to start the Hasura Engine and connectors
together.

#### What did this do?

This created the following file structure in a `my_subgraph/connector/my_ts` directory, with the `functions.ts` file
being your connector's entrypoint:

```bash
.
â”œâ”€â”€ .ddnignore
â”œâ”€â”€ .env.local
â”œâ”€â”€ .hasura-connector
â”œâ”€â”€ connector.yaml
â”œâ”€â”€ docker-compose.my_ts.yaml
# highlight-start
â”œâ”€â”€ functions.ts
# highlight-end
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

### Step 2. Add the DataConnectorLink

As with any other connector, we'll now need to create the `DataConnectorLink` which will translate our TypeScript
functions into commands that can be exposed as queries and mutations via our GraphQL API. Create this using:

```bash
ddn connector-link add my_ts \
  --subgraph my_subgraph/subgraph.yaml \
```

Because we used the convenience flag `--configure-host` on the command, these keys are already set in the
`.env.my_subgraph` file:

```env
MY_SUBGRAPH_MY_TS_READ_URL="http://local.hasura.dev:8083"
MY_SUBGRAPH_MY_TS_WRITE_URL="http://local.hasura.dev:8083"
```

These keys are then already referenced in `my_subgraph/metadata/my_ts/my_ts.hml`.

### Step 3. Install npm package dependencies

Within our `my_ts` directory, let's install any necessary dependencies:

```bash
cd my_subgraph/connector/my_ts && npm i
```

Then, from the `my_ts` directory run this command to use the `dotenv` package to load environment variables from the
`. env.local` file, start the connector, and watch for any changes:

```bash
npx dotenv -e .env.local -- npm run watch
```

:::info Node.js version and Permissions

The `hasura/nodejs` connector uses Node.js version `>=20`. Please make sure you have the correct version installed.

If you get a warning about needing permissions to install globally, you can use `sudo` to install the package with your
user system password:

```bash
sudo npm install -g dotenv-cli
```

:::

## Add a function

By default a **function** â€” in the nomenclature of DDN â€” is already present in our `functions.ts` file. It's designated
as a function by the JSDoc comment using the `@readonly` tag:

```ts
/**
 * @readonly Exposes the function as an NDC function (the function should only query data without making modifications)
 */
export function hello(name?: string) {
  return `hello ${name ?? "world"}`;
}
```

You can add another function simply by exporting a valid TypeScript function.

Generate the relevant metadata objects for your functions:

```bash
ddn connector-link update my_ts \
  --subgraph my_subgraph/subgraph.yaml \
  --env-file my_subgraph/.env.my_subgraph.local \
  --add-all-resources
```

:::info Each function or procedure has tracked metadata

<details>
<summary>For the boilerplate `hello()` function included by default, you'll see a `Hello.hml` file in the `commands` subdirectory
of the connector. Click here to check it out Â»</summary>

```yaml
---
kind: Command
version: v1
definition:
  name: Hello
  outputType: String!
  arguments:
    - name: name
      type: String
  source:
    dataConnectorName: fx_connector
    dataConnectorCommand:
      function: hello
  graphql:
    rootFieldName: hello
    rootFieldKind: Query

---
kind: CommandPermissions
version: v1
definition:
  commandName: Hello
  permissions:
    - role: admin
      allowExecution: true
```

</details>

:::

## Add a procedure

Inside the same `functions.ts` file, let's add a custom mutation in the form of a **procedure**.

For example, let's say you want to add a custom mutation to create a user in a PostgreSQL table on your default `app`
subgraph and also hash their password before storing it.

You can do this by adding the following code to the `functions.ts` file:

```typescript
import { Client } from "pg";
import bcrypt from "bcrypt";

// Define the User type using TypeScript
type User = {
  name: string;
  email: string;
  password: string; // Add a password field to the User type
};

/**
 * Inserts a user into the database and returns the inserted user.
 * Hash password for secure storage.
 *
 * @param user The user to insert into the database. Expects a name, email, and password.
 * @returns The user that was inserted into the database.
 */
export async function insertUser(user: User): Promise<Omit<User, "password">> {
  // Get your database connection string.
  // NB!! Use env vars for this in production NB!!
  const connectionString = "postgresql://username:password@localhost:5432/mydb";

  const client = new Client({
    connectionString,
  });
  await client.connect();

  // Hash the user's password before storing it
  const saltRounds = 10; // Pretty decent number of rounds
  const hashedPassword = await bcrypt.hash(user.password, saltRounds);

  const result = await client.query(
    `INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING *`,
    [user.name, user.email, hashedPassword], // Use the hashed password here
  );

  const rows = result.rows.map((row) => ({
    id: row.id,
    name: row.name,
    email: row.email,
    // Do not return the password field for security reasons
  }));

  await client.end();

  return rows[0];
}
```

This:

- creates a function called `insertUser`.
- takes in a user's name, email, and password.
- hashes their password.
- inserts into the `users` table in the database.
- returns the inserted user without password.

We're using the [`pg` PostgreSQL client](https://www.npmjs.com/package/pg) to connect to the database and run the query
and [`bcrypt` to hash the password](https://www.npmjs.com/package/bcrypt), but since this is a Node.js Lambda function,
you can use any combination of Node.js libraries you want.

You can then repeat this process to scale your mutations independently.

## Testing

After you've generated the metadata for the function or procedure and created a new build, you can use this in your
GraphQL API.

:::info More examples

To see more examples, check out our getting started guide for
[adding custom business logic](/getting-started/build/06-add-business-logic.mdx) or database-specific guides for
[creating mutations](/getting-started/build/08-mutate-data.mdx).

:::
