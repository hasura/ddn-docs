---
sidebar_position: 1
sidebar_label: Basics
description: "Learn how to incorporate custom business logic directly into your GraphQL API."
keywords:
  - hasura
  - hasura ddn
  - cicd
  - api deployment
  - business logic
  - custom
---

# Basics of Business Logic in Hasura DDN

## Introduction

In Hasura DDN, custom business logic is treated as a first-class citizen and like any other data source. This means,
using a **lambda connector**, you can expose a function written in your language of choice return data from it directly
to your GraphQL API.

We treat custom business logic like a data source because it allows for seamless integration into your GraphQL API, just
like databases or other external services. This approach enables you as the API author to unify your data and logic,
ensuring consistent access patterns, security rules, and relationships across all parts of the API.

This custom logic can be used to query or mutate data independently or to extend the functionality of existing
[models](/supergraph-modeling/models.mdx) in your API. By connecting custom logic to other resources, you can enhance
and expand the capabilities of data from different sources.

Treating custom logic as a data source simplifies your architecture, reduces duplication, and makes your APIs more
flexible and maintainable.

:::info Which languages are supported?

Currently, we have lambda connectors for TypeScript, Python, and Go; these connectors and their custom functions can be
hosted by Hasura or on your own infrastructure.

:::

## Functions and procedures

Regardless of which language you prefer, your connector will generate a [command](/supergraph-modeling/commands.mdx) in
your metadata for each function. These commands will be identified in your metadata as either
[functions](/supergraph-modeling/commands.mdx#command-functionname) — for querying data — or
[procedures](/supergraph-modeling/commands.mdx#command-procedurename) — for modifying data — via your API.

Each connector has its own conventions for determining if the custom logic you write is identified as either a function
or a procedure.

## Learn more

- [Learn how to add a lambda connector](/business-logic/add-a-lambda-connector.mdx)
- [Learn how to add independent custom logic to your API](/business-logic/tutorials/1-add-custom-logic.mdx)
- [Learn how to add custom logic to an existing model in your API](/business-logic/tutorials/2-extend-a-model.mdx)

:::info What about custom native operations?

If you're curious about native queries and mutations, check out the
[connector-specific reference docs](/reference/connectors/index.mdx) for generating queries and mutations using the
native capabilities of your data source.

:::
